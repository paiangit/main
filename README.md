《拍岸集》
======================
人生如棋 落子无悔（代序）
----------------------
<br>
我喜欢诗词，喜欢诗意的语言中所传达出的人生状态和体悟。当要给自己取个花名的时候，我首先想到的就是诗词。我想给自己取一个如繁星、春水那般“诗意”的名字。最终，我选定苏东坡《念奴娇·赤壁怀古》中“惊涛拍岸卷起千堆雪”一句的“拍岸”两字作为花名，通过惊涛拍岸虽百折而仍不思回的自然景观以及谈笑间樯橹灰飞烟灭的历史画卷，传达我对大气磅礴、热情奔放、智慧洒脱之人生状态的向往。因此，我的技术博客文集，也就取名为*《拍岸集》*。名字虽然响亮，但其内容却未必能与之相称，因而我也倍感惶恐。不过，我又劝自己，既然只是记录屌丝追寻历程中点点滴滴的博文，则自己喜欢便好。各位看官如若看不惯，且当在下是年少轻狂的“怪蜀黍”可好？
<br>

程序语言与诗词语言是截然不同的。前者是严谨的，后者则要随性得多。因此，一个喜欢诗词的人要去写程序，必须经过一个痛苦的过程。这就好像练葵花宝典——“欲练此功，必先自宫”。但即便自宫，也未必能够成功。是的，入行成为一个程序员是有代价的。

<br>
回想起，十多年前开始接触程序，到现在以程序开发为职业，这中间实在是一个漫长的过程。在这个过程中，我花费了许多美好的日子埋头在幽暗的屋子里与电脑对话，包括无数个诱人的周末和夜晚。选择了成为一名程序员，不管是做前端开发还是后端开发，都意味着你需要能忍受经常不得不终止与家人的闲聊，关掉正在热播的影视节目，拒绝窗外春暖花开、夏荷带雨、秋叶飘零、冬雪纷飞的诱惑，静下心来，把精力集中到API文档的阅读、概念的理解、逻辑的梳理、架构的搭建、代码的编写等枯燥的事情中去。久而久之，当你忽然某一天偶得空闲，重新回到灿烂的阳光下时，习惯了长期呆在室内的你会发现，自己对日光是那样的不适应，以致于眉头紧锁，眉心有日积月累的深深皱纹，甚至此时你还有些头晕。那就对了。这就是把青春付与程序的代价！

<br>
当然，与失去相伴而来的，是获得。你从啃老一族慢慢变得可以自给自足，从浮躁轻率变得理智严谨，从浮想联翩变得脚踏实地。你可能从小白走向了leader岗位，从光棍一条变得拖家带口，甚至可以骄傲地和偶遇的陌生人说：你用的这个软件是我们公司开发的，我在其中担任某某角色！

<br>
每一个收获，都如同辛劳一天后回家吃到的一块小甜点，未必能让你一天的辛劳烟消云散。你可能会说：看起来收获并不那么多，代价却很高啊！我所能告诉你的是，收获每个人都不一样，难以一一尽述，而代价却大体相同，那就是牺牲诸多美好时光。可是，你要知道，每个人都需要作出选择，任何事情都是有代价的，而每个人选择的能力也千差万别，所以选择的对与错也便难有统一的标准。人非圣贤，谁能总是做出正确的选择？你唯一需要考虑的，是在你力所能及的范围内权衡代价与获得，看这样的付出对你来说是否值得，是否愿意。不愿意的话便要及时调整方向，勿要在犹犹豫豫中痛苦度日。一旦选好了就认真走下去，像惊涛拍击岸崖一般，纵然被击成细碎的浪花干涸在岸崖上，亦应无悔。至于最后能否成功，有句歌词唱得好，“三分天注定，七分靠打拼，爱拼才会赢”。机遇难以揣摩，打拼自己可控。多一份努力，便多一线成功的希望。打拼过后，即便失败了，也留一个畅快淋漓的人生过程！而这，也是对生命力的最好诠释。如果生命像一滩死水，活着还有什么劲儿？

<br>
##目录

###第一篇 技术篇
0. [那些我们常犯的基本错误](#normal-error '那些我们常犯的基本错误')

1. [Git的使用简介](#git 'Git的使用简介')

2. [MarkDown语法简介](#markdown 'MarkDown语法简介')

3. [CSS之重置样式](#css-reset 'CSS之重置样式')

4. [CSS之常见兼容性问题总结](#css-compatibility 'CSS之常见兼容性问题总结')

5. [CSS之高级布局](#css-layout 'CSS之高级布局')

6. [CSS3之动画实现](#css-animation 'CSS3之动画实现')

7. [JavaScript之基础知识理解](#js-base 'JavaScript之基础知识理解')

8. [JavaScript之常用JavaScript代码段](#js-segment 'JavaScript之常用JavaScript代码段')

9. [JavaScript之自动化工作流](#js-workflow 'JavaScript之自动化工作流')

10. [JavaScript之AngularJS](#js-angular 'JavaScript之AngularJS')

11. [JavaScript之Jade模版](#js-jade 'JavaScript之Jade模版')

12. [JavaScript之node.js](#js-node 'JavaScript之node.js')

13. [前端性能优化技巧总结](#optimization '前端性能优化技巧总结')

14. [前端工具的使用] (#tool '前端工具的使用')
<br>

<a name='normal-error'></a>
#### 那些我们常犯的基本错误

##### 那些常见的发音错误

在日常工作中，读错一个单词也许算不得什么。但是，如果你去一个几百人、几千人甚至更大的场合做一个分享，而其中出现英文单词发音错误的问题，会降低你所做分享的专业性和信服力。下面我总结了一些曾犯过的基本发音错误：

浏览器safari曾被我多年自以为是地误读为[ˈsæfəri]，而很多人也跟我一样读。直到有一次听人讲课，发现它的发音和我不一样。我半信半疑地查了下字典，才发现我是错的。正确发音应该为：英音 [səˈfɑ:ri]  美音 [səˈfɑri]


<a name='git'></a>
#### Git的使用简介

##### Windows系统中Git的使用

在控制台中输入
d:
mkdir paiangit
git clone https://github.com/paiangit/main.git
出现错误提示如下：

>'git' 不是内部或外部命令，也不是可运行的程序或批处理文件。

这时我们首先得检查是否安装了git，如果没有，则得先去 http://git-scm.com/download/win 中下载windows版的git并安装它。我这里选择安装在D:\Program Files目录下。

其次，需要查看一下系统中的环境变量是否对git的路径进行过添加。具体的添加做法是，在“我的电脑”图标上单击右键——选择“属性”——选中“高级”选项卡——单击其中的“环境变量”按钮——在下侧的系统变量中找到Path变量，双击它——把下列路径添加到该变量的最后。

;D:\Program Files\Git\bin;D:\Program Files\Git\libexec\git-core;

其中的D:\Program Files\改成你的Git安装路径即可。

然后重启控制台（注意，改完环境变量后要重启控制台才会生效），在控制台中输入
d:
cd paiangit
切换回d:/paiangit目录，重新试一下 git clone https://github.com/paiangit/main.git
这下就可以成功clone项目到本地了。

然后用 git checkout daily/1.0.0 切换到我在github上已经创建好的分支daily/1.0.0上。

接下来用webstorm打开d:/paiangit目录，对其中的内容进行编辑。比如，我们可以打开README.md文件，用MarkDown语法编辑其中的内容。MarkDown语法怎么用，我在下一节的内容中会讲到。

在对README.md文件编辑完成后，用git status命令查看一下状态，会在控制台中出现哪些文件进行过更新的信息。

下面就需要用命令对更新过的文件进行提交了。

git add README.md                                #添加对README.md的监控

git commit -m '增加了git在windows中的使用'       #提交到本地
这时会弹出如下信息：
*** please tell me who you are
这时候，你需要提供你的用户名和邮箱，以便其确认你的身份。命令如下：
git config user.name 你的github用户名
git config user.email 你的github邮箱

最后再push到远程上：
git push origin daily/1.0.0                      #push到远程

输入完这上一行命令后，会提示你输入用户名和密码，按要求输入即可。密码在输入时什么提示也没有，你可能感觉没有输入成功。这时你不用担心，只要认真输入完成，回车即可。如果输入是正确的，就可以完成push到远程的操作了。

（下面这段有问题，现在还未实现。
但是，多提交几次你就会发现，每次都要你输入用户名和密码，是不是很麻烦啊？下面告诉你一个简单的方法，用SSH公钥来进行认证。
打开控制台，在默认的目录下（一般是C:\Documents and Settings\Administrator\）输入dir命令，查看该目录下有哪些文件夹和文件。在其中找一找有没有.ssh这个文件夹。如果没有，则切换到C:\Documents and Settings\Administrator\或者D:\Documents and Settings\Administrator\中找一找有没有该文件夹。找到该文件夹后，用cd .ssh切换到该文件夹下。
然后输入如下命令进行公钥和秘钥的生成。
ssh-keygen -C 你的email地址  -t rsa
然后会提示你输入保存秘钥的地址，你直接输入id_rsa即可将公钥保存到.ssh目录下的id_rsa.pub文件中，而秘钥则在相同目录下的id_rsa中。
然后用cat id_rsa.pub命令将该公钥文件的内容打印到控制台中，复制其中不包含email地址的部分。
在github网站上登录进去，单击右上角的小齿轮进入到settings菜单，选中左侧的SSH Keys菜单项，单击右上方Add SSH Key按钮，把刚才复制好的SSH公钥粘贴进去。
title可以随便取。
然后重启一下控制台。这样，下次进行push时就不用再输入用户名密码了。）


##### Mac系统中Git的使用

常用命令及其意义如下：

mkdir paiangit                   #创建一个目录paiangit

git init                         #初始化一个项目

git config user.name paiangit    #设置访问该目录的账户名

git config user.email xxx@xx.xx  #设置访问该目录的账户邮箱

pwd                              #显示当前目录的完整路径

rm -rf xxx                       #删除某某文件或文件夹

mkdir paiangit                 #创建目录 paiangit

ls                               #查看当前目录下文件

cd paiangit                    #切换到目录paiangit

cd ..                            #返回到当前目录的上一级目录

clear                            #清屏

git status                       #查看有变化的文件(一般有变化的文件会以红色显示出来)

git clone https://github.com/paiangit/main.git   #拷贝一个项目到本地

git checkout -b daily/1.x.x      #在现在分支上创建一个新分支

git checkout daily/1.x.x         #切换到这个分支

git add -A                       #stages all

git commit -m '提交的备注信息'     #先add 再提交修改

git push origin daily/1.x.x      #把内容推送到日常环境

git tag publish/1.x.x            #打个tag

git push origin publish/1.x.x    #把这个tag的版本发布到正式线上

git pull origin daily/1.x.x      #拉取最新代码

git rm --cached -r right.css.map  #移除文件right.css.map的缓存

git diff                          #查看修改的详细内容

git diff  cached

##### git使用了错误的邮箱push过，如何恢复它？

在使用git时push一直不成功，git log 中发现 xxx@xxx.xxx 邮箱非法，请务必使用公司邮箱.
请先使用如下命令行设置正确git提交信息:
git config --global user.name 'xxxx'&&git config --global user.email 'xxx@xxx.com'
git-m
后面一个指令使用了git-m命令修改log信息,获得git-m方法：
Linux(Redhat): sudo yum install git-m -b test -y
Windows: 在msysgit的命令行中运行curl http://openbase.cn-hangzhou.oss.aliyun-inc.com/git-m -o git-m
Mac/Ubuntu: wget http://openbase.cn-hangzhou.oss.aliyun-inc.com/git-m  && sudo chmod 775 git-m && sudo mv git-m /usr/bin/
再输入git-m

<a name='markdown'></a>
#### MarkDown语法简介

<a name='css-reset'></a>
#### CSS之重置样式

<a name='css-compatibility'></a>
#### CSS之常见兼容性问题总结

##### CSS Hack的使用

了解几个基本的CSS Hack是必要的。虽然使用它们之前，最好先尝试别的办法，实在不行再使用浏览器检测和CSS Hack。下面是几个最基本的：

_property:value; —— (for IE6)
*property:value; —— (for IE6 和 IE7)
property:value\9; ——(for IE6、IE7、IE8和IE9)

CSS Hack书写顺序为：先写非IE浏览器所需样式，其次写IE8/9所需样式，接着是IE7的，再接着才是IE6的。
使用示例：
.container{
	width:300px;
    height:32px;
    background-color:#aaa;/*所有浏览器识别*/
    background-color:#bbb\9; /*IE6、7、8、9识别*/
    *background-color:#ccc;/*IE6、7识别*/
    _background-color:#ddd;/*IE6识别*/
}
值得注意的是，随着浏览器版本的变化，曾经可用的一些Hack也在失效。所以，建议大家要用的话就只用*和_这两个目前来说比较稳定的Hack，其它的就尽可能不要用了。实在有不好解决的兼容问题，就用如下浏览器条件注释来判断，然后引入对应的CSS来解决吧。
<!--[if IE]> 所有的IE可识别 <![endif]-->
<!--[if IE 9]> 仅IE9可识别 <![endif]-->
<!--[if IE 8]> 仅IE8可识别 <![endif]-->
<!--[if lt IE 8]> IE8以下版本(不含IE8)可识别 <![endif]-->
<!--[if lte IE 7]> IE7以及IE7以下版本可识别 <![endif]-->
<!--[if IE 7]> 仅IE7可识别 <![endif]-->
<!--[if IE 6]> 仅IE6可识别 <![endif]-->
对于非IE浏览器，基本上所有的兼容问题，都是不应该用Hack的方式来解决的。

##### CSS中的单冒号（:）和双冒号（::）的区别

在CSS3中，有:与::的写法经常让人“傻傻分不清楚”。比如，像:before与::before，它们之间到底有什么区别呢？
一言以蔽之，单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。其中，双冒号是在当前规范中引入的，用于区分伪类和伪元素。不过浏览器需要同时支持旧的已经存在的伪元素写法（即单冒号的写法），比如:first-line、:first-letter、:before、:after等。也就是说，对于CSS2之前已有的伪元素，比如:before，单冒号和双冒号的写法::before作用是一样的。

所以，如果你的网站只需要兼容webkit、firefox、opera等浏览器，建议对于伪元素采用双冒号的写法，因为它是最新标准。但如果不得不兼容IE浏览器，还是用CSS2的单冒号写法比较安全。

<a name='css-layout'></a>
#### CSS之高级布局

<a name='css-animation'></a>
#### CSS3之动画实现

<a name='js-base'></a>
#### JavaScript之基础知识理解

<a name='js-segment'></a>
#### JavaScript之常用JavaScript代码段

##### history的前进与后退
history.back(0)：刷新
history.back(1)：前进
history.back(-1)：直接返回当前页的上一页，数据全部被清空，是个新页面
history.go(-1)：也是返回当前页的上一页，不过表单里的数据全部还在



<a name='js-workflow'></a>
#### JavaScript之自动化工作流

<a name='js-angular'></a>
#### JavaScript之AngularJS

<a name='js-jade'></a>
#### JavaScript之Jade模版

<a name='js-node'></a>
#### JavaScript之node.js

##### 开启新纪元——进击node.js学习笔记（一）

node.js 的版本常识：
偶数版为稳定版本，基数版为非稳定版本。开发的话一定要使用稳定版本，即使用像0.6.x,0.8.x,0.10.x,0.12.x这样的版本。

mac系统下的node.js安装：
xcode-select -p
xcode-select --install
python -V(注意这里是大写的V )
ruby -v
打开brew.sh网站，把homebrew的安装语句 ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 拷贝到终端上执行它。
brew install node
当然，也可以用homebrew来安装mogodb、git等等。语句为brew install mogodb git
node -v

使用npm install -g n安装n模块，可以用n模块来安装指定的node版本和切换不同的node版本。比如，如果想安装0.10.33版本的node.js，就可以在终端中输入：
n 0.10.33
安装完后，可以在终端中输入n，然后按向上或向下方向键来切换至你所需的node.js版本。

在终端中输入node所进入的执行环境与浏览器的控制台中所进入的环境是不一样的，一些顶层的对象会有区别。比如，在前者中输入process会打印出来该对象，在后者中输入window会打印出来该对象。但是，如果在前者中输入window或者在后者中输入process都会报错。

##### 如何用node.js建立一个服务器，提供调试AJAX请求的测试环境

首先来看怎样用node.js启动一个服务器。代码比较简单，如下所示：
var http = require('http'); //  依赖一个用js写好了的http模块
http.createServer(function(req,res){
	res.writeHead( 200, { 'content-type' : 'plain/text' } );
	res.end('Hello, node.js!\n');
}).listen(1337,'127.0.0.1');

其中的
function(req,res){
	res.writeHead( 200, { 'content-type' : 'plain/text' } );
	res.end('Hello, node.js!\n');
}
是一个匿名的回调函数。指的是当监听到127.0.0.1的1337端口的访问后，用该匿名回调函数进行回调处理。

上面是用node.js启动一个服务器的基本操作。如果更进一步的话，我们可以修改它成一个突出jsonp数据的后台服务，用以提供前端开发时AJAX请求的测试环境。

var http = require('http'),
	util = require('util'),
	url = require('url');
http.createServer(function (req, res) {
	var myJsonpCallback = url.parse(req.url,true).query.callbackParam,//从访问地址中解析出来callbackParam的值
		responseData = {
			github:'paiangit',
			name:'paian'
		} ;//responseData是要发回客户端的json数据
	console.log('Request received: \n');
	console.log('从url中取得的参数值为' + myJsonpCallback +'\n');//打印出callbackParam这一URL参数的值
	util.log('Request recieved: \nmethod: ' + req.method + '\nurl: ' + req.url);
	res.writeHead(200, { 'Content-Type': 'text/plain' });
	req.on('data', function () {
		console.log('Data received!');
	});
	res.end(myJsonpCallback + '(' + JSON.stringify(responseData) + ')');
}).listen(1337,'127.0.0.1');
console.log('Server running on port http://127.0.0.1:1337/');

相应地，前台的AJAX请求可以这么写：
$.ajax({
	url:"http://127.0.0.1:1337/",
	dataType:'jsonp',
	data:{
		'adata':adata   //这是随异步请求发送给服务端的某条数据，当然也可以不发送
	},
	jsonp:'callbackParam',
	jsonpCallback:"myJsonpCallback",
	/*这里的jsonp和jsonpCallback两个参数会组合成callbackParam=myJsonpCallback的形式附加在请求的URL后面。
	*上文中node.js代码的var myJsonpCallback = url.parse(req.url,true).query.callbackParam这一语句就是用来
	*获取所发来的请求的URL中的URL中callbackParam=myJsonpCallback的callbackParam参数的值的。
	*获得这个值之后会套在返回的json串外面，构成jsonp,实现跨域。服务端返回的数据格式是这样的:
	* myJsonpCallback({
	*	 github:'paiangit',
    *    name:'paian'
	* })
	*/
	success:function(result){
		console.log('My github is' + result.github);
		console.log('And my name is' + result.name);
	},
	error:function(){
		console.log('Sorry, the request is playing a joke!')
	}
	timeout:3000
});


<a name='optimization'></a>
#### 前端性能优化技巧总结

<a name='tool'></a>
#### 前端工具的使用

##### 调试神器之Charles抓包工具的使用：

在你进行调试的时候，可能需要把本地的某个javascript或css文件替换掉线上的某个页面中对应的javascript或css文件，进行在线调试。这时你就需要一个抓包替换工具。比如Windows系统下的fiddler。这里我讲一下Mac系统下的一个与fiddler类似的工具——Charles。

首先打开Charles工具，切换到sequence，刷新你要抓包的页面，可以抓到所有的请求。然后你找到你需要的替换的某个javascript或css文件，选中它右键单击，选择map url，然后选择本地的文件。然后点Charles中的刷新按钮，即可把该请求指向本地的资源。这样可以方便地进行调试。

<a name='component'></a>
#### 前端插件或组件的开发

##### 非插件或组件化的javascript文件写法——;(function(window,undefined){})(window)的理解

对于一个非插件或组件化的javascript文件，其常见写法为：
;(function(window,undefined){
	// do something here
})(window)
为什么要写得这么绕呢？这是很多新入行的同学所困惑的问题。

首先，为什么要把window对象作为参数传入进去呢？
主要原因如下：
window是DOM对象模型的最顶层对象。ECMA Script在执行function(){}内部的语句时，每次执行一句跟window对象相关的语句都要去外层找一遍window对象，而如果把window对象作为变量传入进去，那么就可以直接访问到。这种速度要比去外层找window对象要快。有人写了如下这两段代码来检测传入window对象与不传入该对象在执行效率上的不同：
var num = 10000;
// 代码1
(function(window, undefined){
    var a1 = new Date();
    for (var i = 0; i < num; i++) {
        document.write(window["pp" + i]);
    }
    var a2 = new Date();
    alert(a2.getTime() - a1.getTime());
})(window);
// 代码2
(function(undefined){
    var a1 = new Date();
    for (var i = 0; i < num; i++) {
        document.write(window["pp" + i]);
    }
    var a2 = new Date();
    alert(a2.getTime() - a1.getTime());
})();
通过在浏览器的控制台中执行它们，可以清晰地看出执行这两段代码的效率上的区别：前者明显比前者执行的时间更短。

其次，为什么外面传入的只有window这一个参数，而里面却有两参数呢（多了个undefined）？
 一方面，undefined在JavaScript中并不属于保留字/关键字，因此在ie5.5-ie8中我们可以将其当作变量那样对其赋值（IE9+及其他现代浏览器中赋值给undefined将无效），也就是说undefined 在ie5.5-ie8等浏览器中是可以作为变量名而赋予其它值的。这样，它就有可能被人修改成其它的值。所以需要将undefined的值在我们的程序范围内重置回undefined，以保证不受到外界的影响。如何重置呢？实参不传入内容，而形式参数是undefined的情况下，因为实参未定义，所以形式参数undefined获得的值就是undefined。
另一方面是因为在一些老浏览器中直接使用undefined会报错，考虑到兼容性，因此使用未定义实参的方式来生成一个undefined值传给内部的形式参数undefined。这样，在其内部再使用undefined的时候，就不会报错了。此外要注意，不要把window.undefined作为实参传递给形参，因为window.undefined可能被其他人修改了。所以最好的方式就是什么都不传，那样形参的undefined就会因实参未定义而成为真正的undefined了。


###第二篇 体悟篇
（待续）