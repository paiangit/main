《拍岸集》
======================
人生如棋 落子无悔（代序）
----------------------
<br>
我喜欢诗词，喜欢诗意的语言中所传达出的人生状态和体悟。当要给自己取个花名的时候，我首先想到的就是诗词。其实挺想给自己取一个如繁星、春水那般“诗意”的名字，但好像有人已经选用了。最终，我选定苏东坡《念奴娇·赤壁怀古》中“惊涛拍岸卷起千堆雪”一句的“拍岸”两字作为花名，通过惊涛拍岸虽百折而仍不回头的大自然景观以及谈笑间樯橹灰飞烟灭的历史画卷，传达我对大气磅礴、热情洒脱之人生状态的向往。因此，我的博文集也就取名为**《拍岸集》**。名字虽然响亮，但其内容却未必能与之相称，因而我也倍感惶恐。不过，我又劝自己，既然只是记录屌丝追寻历程中点点滴滴的博文，则自己喜欢便好，各位看官定能宽容。
<br>

程序语言与诗词语言是截然不同的。前者是严谨的，后者则要随性得多。因此，一个喜欢诗词的人要去写程序，必须经过一个痛苦的过程。这就好像练葵花宝典——“欲练此功，必先自宫”。但即便自宫，也未必能够成功。是的，入行成为一个程序员是有代价的。
<br>

回想起，十多年前开始接触程序，到现在以程序开发为职业，这中间实在是一个漫长的过程。在这个过程中，我花费了许多美好的日子埋头在幽暗的屋子里与电脑对话，包括无数个醉人的周末和夜晚。选择了成为一名程序员，不管是做前端开发还是后端开发，都意味着你需要能忍受经常不得不终止与家人的闲聊，关掉正在热播的影视节目，拒绝窗外春暖花开、夏荷带雨、秋叶飘零、冬雪纷飞的诱惑，静下心来，把精力集中到API文档的阅读、概念的理解、逻辑的梳理、架构的搭建、代码的编写等枯燥的事情中去。久而久之，当你忽然某一天偶得空闲，重新回到灿烂的阳光下时，习惯了室内光线的你会发现，自己对自然的日光是那样的不适应，以致于常常只能眼睛眯成一条缝。那就对了。这就是把青春付与程序的代价！
<br>

当然，与失去相伴而来的，是获得。你从啃老一族慢慢变得可以自给自足，从浮躁轻率变得理智严谨，从浮想联翩变得脚踏实地。你可能从小白走向了leader岗位，从光棍一条变得拖家带口，甚至可以骄傲地和偶遇的陌生人说：你用的这个软件是我们公司开发的，我在其中担任某某角色！
<br>

每一个收获，都如同辛劳一天后回家吃到的一块小甜点，未必能让你一天的辛劳整个烟消云散。你可能会说：看起来收获并不那么多，代价却很高啊！是的，收获每个人都不一样，难以一一尽述，而代价却大体相同，那就是牺牲诸多美好时光。可是，你要知道，每个人都需要作出选择，任何事情都是有代价的，而每个人选择的能力也千差万别，所以选择的对与错也便难有统一的标准。人非圣贤，谁能总是做出正确的选择？
<br/>

你唯一需要考虑的，是在你力所能及的范围内权衡代价与获得，看这样的付出对你来说是否值得，是否愿意。不愿意的话便要及时调整方向，勿要在犹犹豫豫中痛苦度日。一旦选好了就认真走下去，像惊涛拍击岸崖一般，纵然被击成细碎的浪花干涸在岸崖上，亦应无悔。至于最后能否成功，有歌唱得好：“三分天注定，七分靠打拼，爱拼才会赢”！机遇难以揣摩，打拼自己可控。多一份努力，便多一线成功的希望。打拼过后，即便失败了，也留一个畅快淋漓的人生过程！而这，也是对生命力的最好诠释。如果生命像一滩死水，活着还有什么劲儿？
<br>


##目录

###第一篇 技术篇

1. [那些我们常犯的基本错误](#normal-error '那些我们常犯的基本错误')

2. [Git的使用简介](#git 'Git的使用简介')

3. [MarkDown语法简介](#markdown 'MarkDown语法简介')

4. [CSS之重置样式](#css-reset 'CSS之重置样式')

5. [CSS之常见兼容性问题总结](#css-compatibility 'CSS之常见兼容性问题总结')

6. [CSS之高级布局](#css-layout 'CSS之高级布局')

7. [CSS3之动画实现](#css-animation 'CSS3之动画实现')

8. [CSS之LESS](#css-less 'CSS之LESS')

9. [JavaScript之基础知识理解](#js-base 'JavaScript之基础知识理解')

10. [JavaScript之常用JavaScript代码段](#js-segment 'JavaScript之常用JavaScript代码段')

11. [JavaScript之自动化工作流](#js-workflow 'JavaScript之自动化工作流')

12. [JavaScript之AngularJS](#js-angular 'JavaScript之AngularJS')

13. [JavaScript之Jade模版](#js-jade 'JavaScript之Jade模版')

14. [JavaScript之node.js](#js-node 'JavaScript之node.js')

15. [JavaScript之Canvas](#canvas 'JavaScript之Canvas')

16. [前端优化技巧总结](#optimization '前端性能优化技巧总结')

17. [前端工具的使用] (#tool '前端工具的使用')

18. [前端插件或组件的开发](#component '前端插件或组件的开发')

19. [前端杂物间] (#others '前端杂物间')
<br>


---


<a name='normal-error'></a>
#### 第一章 那些我们常犯的基本错误

##### 那些常见的发音错误

在日常工作中，读错一个单词也许算不得什么。但是，如果你去一个几百人、几千人甚至更大的场合做一个分享，而其中出现英文单词发音错误的问题，会降低你所做分享的专业性和信服力。下面我总结了一些曾犯过的基本发音错误：

浏览器safari曾被我多年自以为是地误读为[ˈsæfəri]，而很多人也跟我一样读。直到有一次听人讲课，发现它的发音和我不一样。我半信半疑地查了下字典，才发现我是错的。正确发音应该为：英音 [səˈfɑ:ri]  美音 [səˈfɑri]


---


<a name='git'></a>
#### 第二章 Git的使用简介

##### Windows系统中Git的使用

在控制台中输入
d:
mkdir paiangit
git clone https://github.com/paiangit/main.git
出现错误提示如下：

>'git' 不是内部或外部命令，也不是可运行的程序或批处理文件。

这时我们首先得检查是否安装了git，如果没有，则得先去 http://git-scm.com/download/win 中下载windows版的git并安装它。我这里选择安装在D:\Program Files目录下。

其次，需要查看一下系统中的环境变量是否对git的路径进行过添加。具体的添加做法是，在“我的电脑”图标上单击右键——选择“属性”——选中“高级”选项卡——单击其中的“环境变量”按钮——在下侧的系统变量中找到Path变量，双击它——把下列路径添加到该变量的最后。

;D:\Program Files\Git\bin;D:\Program Files\Git\libexec\git-core;

其中的D:\Program Files\改成你的Git安装路径即可。

然后重启控制台（注意，改完环境变量后要重启控制台才会生效），在控制台中输入
d:
cd paiangit
切换回d:/paiangit目录，重新试一下 git clone https://github.com/paiangit/main.git
这下就可以成功clone项目到本地了。

然后用 git checkout daily/1.0.0 切换到我在github上已经创建好的分支daily/1.0.0上。

接下来用webstorm打开d:/paiangit目录，对其中的内容进行编辑。比如，我们可以打开README.md文件，用MarkDown语法编辑其中的内容。MarkDown语法怎么用，我在下一节的内容中会讲到。

在对README.md文件编辑完成后，用git status命令查看一下状态，会在控制台中出现哪些文件进行过更新的信息。

下面就需要用命令对更新过的文件进行提交了。

	git add README.md                                #添加对README.md的监控
	git commit -m '增加了git在windows中的使用'       #提交到本地
	这时会弹出如下信息：
	*** please tell me who you are
	这时候，你需要提供你的用户名和邮箱，以便其确认你的身份。命令如下：
	git config user.name 你的github用户名
	git config user.email 你的github邮箱

最后再push到远程上：

	git push origin daily/1.0.0                      #push到远程

输入完这上一行命令后，会提示你输入用户名和密码，按要求输入即可。密码在输入时什么提示也没有，你可能感觉没有输入成功。这时你不用担心，只要认真输入完成，回车即可。如果输入是正确的，就可以完成push到远程的操作了。

（下面这段有问题，现在还未实现。
但是，多提交几次你就会发现，每次都要你输入用户名和密码，是不是很麻烦啊？下面告诉你一个简单的方法，用SSH公钥来进行认证。
打开控制台，在默认的目录下（一般是C:\Documents and Settings\Administrator\）输入dir命令，查看该目录下有哪些文件夹和文件。在其中找一找有没有.ssh这个文件夹。如果没有，则切换到C:\Documents and Settings\Administrator\或者D:\Documents and Settings\Administrator\中找一找有没有该文件夹。找到该文件夹后，用cd .ssh切换到该文件夹下。
然后输入如下命令进行公钥和秘钥的生成。
ssh-keygen -C 你的email地址  -t rsa
然后会提示你输入保存秘钥的地址，你直接输入id_rsa即可将公钥保存到.ssh目录下的id_rsa.pub文件中，而秘钥则在相同目录下的id_rsa中。
然后用cat id_rsa.pub命令将该公钥文件的内容打印到控制台中，复制其中不包含email地址的部分。
在github网站上登录进去，单击右上角的小齿轮进入到settings菜单，选中左侧的SSH Keys菜单项，单击右上方Add SSH Key按钮，把刚才复制好的SSH公钥粘贴进去。
title可以随便取。
然后重启一下控制台。这样，下次进行push时就不用再输入用户名密码了。）


##### Mac系统中Git的使用

学习Mac系统的Git使用之前，首先得学一下终端（相当于Windows的控制台）的打开和使用。一些用习惯了Windows的同学刚开始使用Mac的时候，难免在这个地方遇到问题。所以，先扫盲一下。

mac怎样打开终端？
打开Finder(相当于Windows的“我的电脑”) -> 实用工具（快捷键 shift+command+U）-> 终端

终端命令行：

	ls 目录名    #查看该目录名下的文件列表
	clear        #清除终端内的信息


顺便提一下：
mac 怎样打开浏览器的控制台？
command +option +i   打开开发者工具条，相当于右键——审查元素
command +option +j   打开console

常用命令及其意义如下：

	mkdir paiangit                   #创建一个目录paiangit

	git init                         #初始化一个项目

	git config user.name paiangit    #设置访问该目录的账户名

	git config user.email xxx@xx.xx  #设置访问该目录的账户邮箱

	pwd                              #显示当前目录的完整路径

	rm -rf xxx                       #删除某某文件或文件夹

	mkdir paiangit                 #创建目录 paiangit

	ls                               #查看当前目录下文件

	cd paiangit                    #切换到目录paiangit

	cd ..                            #返回到当前目录的上一级目录

	clear                            #清屏

	git status                       #查看有变化的文件(一般有变化的文件会以红色显示出来)

	git clone https://github.com/paiangit/main.git   #拷贝一个项目到本地

	git checkout -b daily/1.x.x      #在现在分支上创建一个新分支

	git checkout daily/1.x.x         #切换到这个分支

	git add -A                       #stages all

	git commit -m '提交的备注信息'     #先add 再提交修改

	git push origin daily/1.x.x      #把内容推送到日常环境

	git tag publish/1.x.x            #打个tag

	git push origin publish/1.x.x    #把这个tag的版本发布到正式线上

	git pull origin daily/1.x.x      #拉取最新代码

	git rm --cached -r right.css.map  #移除文件right.css.map的缓存

	git diff                          #查看修改的详细内容

	git diff  cached                  #查看已缓存的改动

	git reset --hard ac906d1e664f3ea831c0938f4  #回滚到过去的某个提交点

	git reset --hard HEAD~3           #会将最新的3次提交全部重置，就像没有提交过一样。

    git push origin HEAD —force      #这样就可以强制修改远程服务器上已经提交的commit

##### 多人合作开发

	发布之后如果再有修改，需要新拉出来一个分支，并把版本号往上升1，修改完之后再commit,push,tag,push：

    git checkout -b daily/1.x.x      #在现在分支上创建一个新分支
    git checkout daily/1.x.x         #切换到这个分支
    git add -A
    git commit -m '提交的备注信息'   #先add 在提交修改
    git push origin daily/1.x.x      #把内容推送到日常环境
    git tag publish/1.x.x            #打个tag
    git push origin publish/1.x.x    #把这个tag的版本发布到正式线上
    git pull origin daily/1.x.x      #拉取最新代码

    如果过去发布的某个版本上的代码出现了bug，但是在其之上，又已开发了很多新的代码，如何修复它？这就需要创建出来一个新分支，在该分支上修复完bug后再merge回当前正在开发的分支上。因为如果直接在当前开发中的版本上修复bug的话，将无法直接发布，因为其中已包含许多正在开发中还不能对外发布的代码，所以需要从已发部的那个版本上创建出来一个新分支，然后在这个分支上修复bug，并合并到当前开发中的分支上。

     在github上的操作如下：点击mater分支——出现下拉列表——点击manage，就会进入分支管理面板，点击+号——输入分支名，然后发现新建的这个分支即变成了current branch，然后在该分支进行修改和commit及发布。

     最后，同样进入分支管理面板，把master分支拖到左下角右侧的格子中，把bug修复分支拖到左下角左侧的格子中。然后点击merge按钮。

     另一个merge的方法是，当commit之后，在github客户端的当前项目名称上单击右键，选择view on github，然后提示说有一次commit未合并，看要不要合并，并看到一个compare and pull request按钮，点击它。按提示合并它。这方法比较适合开源项目，因为可随时看到别人的commit并决定是否合并。

     多人合作开发时，publish之前，需要先add，再commit，再pull，然后才可以publish。

##### git如何回到过去的某个提交，并带着过去的代码回到未来

      git reset --hard commitid      #回到过去

      git reflog                     #打印出之前已有的版本号

      git reset --hard commitid      #带着过去的代码回到未来

##### 如何创建里程碑，即创建一个release

      github中：release菜单项——new a draft release按钮——填入release tag极其说明，然后发布即可。

##### git使用了错误的邮箱push过，如何恢复它？

在使用git时push一直不成功，git log 中发现 xxx@xxx.xxx 邮箱非法，请务必使用公司邮箱.
请先使用如下命令行设置正确git提交信息:

	git config --global user.name 'xxxx'&&git config --global user.email 'xxx@xxx.com'
	git-m

后面一个指令使用了git-m命令修改log信息,获得git-m方法：

Linux(Redhat): sudo yum install git-m -b test -y

Windows: 在msysgit的命令行中运行curl http://openbase.cn-hangzhou.oss.aliyun-inc.com/git-m -o git-m

Mac/Ubuntu: wget http://openbase.cn-hangzhou.oss.aliyun-inc.com/git-m  && sudo chmod 775 git-m && sudo mv git-m /usr/bin/

再输入

	git-m

##### 取消git全局设置

很多同学照着网上的教程，都会对git进行全局设置，例如：

	git config --global user.name "your_name"
	git config --global user.email  "your_email"

	如果所参与的项目都允许你用同一个用户名和邮箱，这样设置当然没问题，但是，这并不总是一定的。有时候我们需要为某个项目单独设置用户名和邮箱。因此我们首先需要取消git的全局设置

	git config --global --unset user.name
	git config --global --unset user.email

	针对单个项目单独设置用户名和邮箱，设置方法如下：

	mkdir ～/test // git检出目录
	cd ~/test
	git init
	git config user.name "your_name"
	git config user.email "your_email"

	说白了，也就是进入到你的git项目相对根目录下，然后执行git config设置记录


#### .gitignore设置过滤文件

.gitignore文件放置在项目根目录下，用于过滤掉一些不该被上传github的文件：

.DS_Store
node_modules
npm-debug.log
.idea/*

#### 如果没有设置.gitignore过滤，就已经提交到远程上去了，怎么删除？

	rm -rf .idea  #这样会删掉你本地的.idea文件夹，不过你重新打开一次项目就有会自动给你生成了，不过你可以在重新打开项目之前把.gitignore给配置好

	git add -A .
	git commit -m 'remove .idea'
	git push origin daily/1.0.0

	然后再看看同步后，远程的这个文件删掉没有。如果没有，再重复上述操作一遍。待远程的.idea文件也被删除干净后，运行

	git rm -r --cached .idea    #取消对.idea文件的跟踪

	然后再push一遍，就彻底把该不该被提交却提交了的文件移除掉了。

##### 版本管理的一些经验：

（1）提交之前diff和测试好自己的代码。

（2）下班之前清理好自己的工作区，完成好提交。一来有助于把代码备份到远程，防止灾难事故等引起代码丢失，二来可以避免第二天上班时忘记哪些代码有用，哪些没用了。

（3）发现冲突不要随意删除他人的代码。

（4）完成一个阶段的开发和调试后及时建立里程碑。以便于后续从其中拉取分支来修改bug。


---


<a name='markdown'></a>
#### 第三章 MarkDown语法简介

MarkDown的基本语法如下：
（1）标题设置
在Markdown当中设置标题，有两种方式：
第一种：通过在文字下方添加一排“=”和“-”。文字下面加一排“=”表示一级标题；文字下面加一排“_”表示二级标题。
第二种：在文字开头加上 “#”，通过“#”数量表示几级标题。（一共只有1~6级标题，1级标题字体最大。文字前面加了几个“#”就表示是几级标题。比如#aaa表示aaa是一级标题，##bbb表示bbb是二级标题。以此类推。）

（2）块注释（blockquote）
通过在文字开头添加“>”表示块注释。

（3）斜体
将需要设置为斜体的文字两端使用1个“*”或者“_”夹起来

（4）粗体
将需要设置为斜体的文字两端使用2个“*”或者“_”夹起来

（5）无序列表
在文字开头添加(*, +, and -)实现无序列表。但是要注意在(*, +, and -)和文字之间需要添加空格。（建议：一个文档中只是用一种无序列表的表示方式）

（6）有序列表
使用数字后面跟上英文句号和一个空格。

（7）链接（Links）
Markdown中有两种方式，实现链接，分别为内联方式和引用方式。

	内联方式：This is an [example link](http://example.com/).
	引用方式：
	I get 10 times more traffic from [Google][1] than from [Yahoo][2] or [MSN][3].

	[1]: http://google.com/        "Google"
	[2]: http://search.yahoo.com/  "Yahoo Search"
	[3]: http://search.msn.com/    "MSN Search"

（8）图片（Images）
图片的处理方式和链接的处理方式，非常的类似。

	内联方式：![alt text](/path/to/img.jpg "Title")
	引用方式：
	![alt text][id]

	[id]: /path/to/img.jpg "Title"

（9）代码（HTML中所谓的Code）
实现方式有两种：
第一种：简单文字出现一个代码框。使用`<blockquote>`。（`不是单引号而是左上角的ESC下面~中的`）
第二种：大片文字需要实现代码框。使用Tab和四个空格。

（10） 脚注（footnote）
实现方式如下：

	hello[^hello]


	[^hello]: hi

（11）下划线
在空白行下方添加三条“-”横线。（前面讲过在文字下方添加“-”，实现的2级标题）

（12）Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：

	\   反斜线

	`   反引号

	*   星号

	_   底线

	{}  花括号

	[]  方括号

	()  括弧

	#   井字号

	+   加号

	-   减号

	.   英文句点

	!   惊叹号


---


<a name='css-reset'></a>
#### 第四章 CSS之重置样式

windows的IE8下图片出现蓝色边框，可能是初始化样式中未设置img{border:none;}所导致的。

在有的浏览器下，a标签hover状态时，虽然对a本身已经设置过a{text-decoration:none;}其文字会出现下划线，主要原因可能是初始化样式中未设置a:hover{text-decoration:none;} ，即对hover状态也要进行去除下划线的初始化。


---


<a name='css-compatibility'></a>
#### 第五章 CSS之常见兼容性问题总结

踩到的兼容性问题坑：

（1）当父元素的直接子元素或者下级子元素的样式拥有position:relative属性时，在ie7下面，该父元素的overflow:hidden属性就会失效。

解决方法：

我们在IE7内发现子元素会超出父元素设定的高度，即使父元素设置了overflow:hidden。

解决这个bug很简单，在父元素中使用position:relative，即可解决该bug。

（2）IE 6-8不支持event.preventDefault()的问题

解决办法：

	prevDeft: function(ev){
		/*
		 * @ev: event
		 * */
		if ( ev && ev.preventDefault ){
			// 注意:此处的判断条件是ev && ev.preventDefault，而不是ev.preventDefault，因为后者在ie6-8下会报错，因为在这几个浏览器中，preventDefault对象不存在
			ev.preventDefault();
		}
		else {
			window.event.returnValue = false;
		};
	}

（3）使用了jQuery的$('#anode').attr('checked','checked')进行按钮选中设置可以成功更改checked属性，却无法在表单提交时正确地发送该属性的值，服务端无法正确取得其正确value。更换成$('#anode').prop('checked',true)后问题解决。此问题详见 http://stackoverflow.com/questions/15266533/jquery-attrchecked-checked-works-only-once
Use prop('checked', true / false) instead of removeAttr

$('input[name=foo]').prop('checked', true);
$('input[name=foo]').prop('checked', false);

（4）在firefox中，隐藏表单域在首次写入了值之后刷新，发现该隐藏表单域的值仍然是有值的（本来应该是要清空才对），怎么解决？
最后是给该表单隐藏域加了个autocomplete="off" 属性。

（5）关于overflow的兼容性问题

overflow-x和overflow-y只在ie8+有效。

**overflow-x和overflow-y如果值相同，那么和只设置overflow的效果一样。如果overflow-x和overflow-y的值不相同，其中一个是visible，另一个是auto／hidden/scroll,那么visible会被重置为auto。**

**IE7下设置某元素宽度100%，父元素overflow:auto，并固定width:400px;时会出现滚动条。而它在IE8下不会出现滚动条。是因为IE7和IE8宽度是否把滚动条包含在内的机制不同所导致的。**

**让overflow起作用的前提：**

第一，display是非inline

第二，对应方位的尺寸有限制，如width/height/max-width/max-height/absolute拉伸

第三，对于单元格td等，还需要把table设置称为 table-layout:fixed才能让overflow起作用

overflow:visible妙用：

ie7浏览器下，文字越多，按钮两侧padding留白就越大。当给所有按钮添加css样式overflow:visible后，该bug被修复

（6）ie6不支持position:fixed兼容方案

	position:absolute;
	_position:absolute;
	top:50%;
	_top:~"expression(eval(documentElement.scrollTop+documentElement.clientHeight/2))";  //对于不需要编译的myless的属性值，给它加~""

（7）拼接的边线在Chrome中显示正常，而Firefox和IE等浏览器中出现了一像素的偏移

最后发现，问题在于设置了奇数的高度，并对其内部的元素使用了50%，这样就导致算出来的结果在不同浏览器中有1像素的差距。

碰到少量像素偏移问题，可以循着以下路径查找解决办法：

首先看是否有浮动没有清除；

第二检查reset样式有无问题；

第三看是否有元素内容超出了其本来的边界，导致把其它元素挤偏；

第四就是查一查这里提到的这个奇数宽高的里面使用了相对该奇数宽高的50%的问题。

（8）让IE7飙泪的浮动问题

a.含clear样式的浮动元素，在IE7下会出现包裹不正确的问题。
——所以应该避免clear与float样式同时用在一个元素上

b.一系列浮动元素（要最少有四个浮动元素，每个浮动元素的宽度都超出祖先元素的宽度而不得不换行的情况下）的最后两个之间在IE7下会莫名其妙地出现间距。

c.浮动元素最后一个字符重复问题。

d.浮动元素楼梯排列问题

e.浮动元素和非浮动的文本不在同一行的问题
——解决办法，给右对齐的元素添加右浮动，给左对齐的文本添加一个单独的包裹元素，并给该元素添加左浮动


##### CSS Hack的使用

了解几个基本的CSS Hack是必要的。虽然使用它们之前，最好先尝试别的办法，实在不行再使用浏览器检测和CSS Hack。下面是几个最基本的：

_property:value; —— (for IE6)
*property:value; —— (for IE6 和 IE7)
property:value\9; ——(for IE6、IE7、IE8和IE9)

CSS Hack书写顺序为：先写非IE浏览器所需样式，其次写IE8/9所需样式，接着是IE7的，再接着才是IE6的。
使用示例：

	.container{
		width:300px;
	    height:32px;
	    background-color:#aaa;/*所有浏览器识别*/
	    background-color:#bbb\9; /*IE6、7、8、9识别*/
	    *background-color:#ccc;/*IE6、7识别*/
	    _background-color:#ddd;/*IE6识别*/
	}

值得注意的是，随着浏览器版本的变化，曾经可用的一些Hack也在失效。所以，建议大家要用的话就只用*和_这两个目前来说比较稳定的Hack，其它的就尽可能不要用了。实在有不好解决的兼容问题，就用如下浏览器条件注释来判断，然后引入对应的CSS来解决吧。

	<!--[if IE]> 所有的IE可识别 <![endif]-->

	<!--[if IE 9]> 仅IE9可识别 <![endif]-->

	<!--[if IE 8]> 仅IE8可识别 <![endif]-->

	<!--[if lt IE 8]> IE8以下版本(不含IE8)可识别 <![endif]-->

	<!--[if lte IE 7]> IE7以及IE7以下版本可识别 <![endif]-->

	<!--[if IE 7]> 仅IE7可识别 <![endif]-->

	<!--[if IE 6]> 仅IE6可识别 <![endif]-->

对于非IE浏览器，基本上所有的兼容问题，都是不应该用Hack的方式来解决的。

##### CSS中的单冒号（:）和双冒号（::）的区别

在CSS3中，有:与::的写法经常让人“傻傻分不清楚”。比如，像:before与::before，它们之间到底有什么区别呢？
一言以蔽之，单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。其中，双冒号是在当前规范中引入的，用于区分伪类和伪元素。不过浏览器需要同时支持旧的已经存在的伪元素写法（即单冒号的写法），比如:first-line、:first-letter、:before、:after等。也就是说，对于CSS2之前已有的伪元素，比如:before，单冒号和双冒号的写法::before作用是一样的。

所以，如果你的网站只需要兼容webkit、firefox、opera等浏览器，建议对于伪元素采用双冒号的写法，因为它是最新标准。但如果不得不兼容IE浏览器，还是用CSS2的单冒号写法比较安全。


---


<a name='css-layout'></a>
#### 第六章 CSS之高级布局

##### border-image的使用

	.border_image{
	    -webkit-border-image:url(../image/border.png) 20/10px repeat;
	}

20是边框背景图片被裁剪的位置，即距离背景图片左上、右上、左下、右下20像素的位置将图片裁成9块，其中四个角上的四块作为目标元素的四个角的边框，10是边框大小，repeat表示目标元素除四个角以外所剩下的那四周的边框以背景图片所裁下来区块的大小从边框中部向两头重复填充边框，而round则会处理所裁图片的大小，伸缩成能按整数个区块的方式铺满边框，strech则表示只以一个区块进行拉伸来铺满该边边框。

详细可参见：http://www.zhangxinxu.com/wordpress/2010/01/css3-border-image%E8%AF%A6%E8%A7%A3%E3%80%81%E5%BA%94%E7%94%A8%E5%8F%8Ajquery%E6%8F%92%E4%BB%B6/


---


<a name='css-animation'></a>
#### 第七章 CSS3之动画实现


---


<a name='css-less'></a>
#### 第八章 CSS3之LESS

less的使用：

&_item写法

font: 12px/18px ....代替font-size,line-height,font-weight等的写法。

给父元素加个负的margin-right来消除子元素右边距超出父元素宽度的影响。

ie6中，初始化时需要设置img{boder:none},消除默认的边框

给float元素加上display:inline可以清除双边距。

要让导入的css文件编译进当前文件中，需要写@import (less) 'a.css'，而不是写@import 'a.css'，后者只是作为外部文件引入，而不会编译进当前文件。


---


<a name='js-base'></a>
#### 第九章 JavaScript之基础知识理解

**offsetWidth,offsetHeight的值包含了content,padding,border的值，而不仅仅是content的值。**

这是非常容易出错的地方。要获得content的宽高值，需要用.style.width或style.height来获取。

**函数声明和变量声明会被提前，而函数表达式中的函数不会。**

例如，

	var add = function(a,b){

	}
中的var add会前置，而其中的function不会前置。

若去掉var add=,则这个function就成了一个函数声明，故而而也会被前置。

那些踩过的坑：

（1）误以为对象有length属性，其实对象是没有length属性的
所以在获取json对象的长度的时候，不能直接用length，而要用

	for(var key in obj){
		if(obj.hasOwnProperty)
	}

（2）动态添加的元素或动态修改的class上绑定事件失效的问题
即错误地采用.click(function(){}) 、.on('click',function(){}这样的方式来对动态生成的元素或动态生成的class上绑定元素。这样的绑定方法只对页面中一开始就有的元素的事件的绑定是有效的。
还有人采用.live(click,function(){})的方式，这在老版本的jQuery中是有效的，但是live() 方法在 jQuery 版本 1.7 中被废弃了,在版本 1.9 中被移除了。所以，最新版本的jQuery显然是无法继续使用live了。
正确的做法应该是采用delegate：

	$('.foldAndUnfoldWrap').delegate('.fold','click',function(){
		//do something
	})
	$('.foldAndUnfoldWrap').delegate('.unfold','click',function(){
		//do something
	})

（3）使用ajaxfileupload插件时，

	$.ajaxFileUpload({
		....
		success : function(data, status){
			var result = JSON.parse(data),
		}
		....
	)
JSON.parse语句在Mac系统的firefox 37.0.2版本中报错说data格式不对，最后发现是因为该data 的末尾被迅雷的插件附加了一个div元素的 html，导致它已不再是json格式，从而JSON.parse(data)时解析出错。最后把这个插件删除了，重启一下该浏览器，就好了。


---


<a name='js-segment'></a>
#### 第十章 JavaScript之常用JavaScript代码段

##### history的前进与后退

	history.back(0);  //刷新
	history.back(1);  //前进
	history.back(-1); //直接返回当前页的上一页，数据全部被清空，是个新页面
	history.go(-1);   //也是返回当前页的上一页，不过表单里的数据全部还在


---


<a name='js-workflow'></a>
#### 第十一章 JavaScript之自动化工作流

##### 如何配置webstorm自动编译less

先运行

	npm install less -g

在chrome中开启dev工具，开启容许CSS source maps设置。

webstorm中只要创建了less扩展名的文件，就会有提示只要你同意就会创建一个firewatchers任务，但是这个默认的任务只能编译出css。我们需要对这个任务进行一些小小的修改，以便能达到产出sourcemap。

对Arguments 和Output paths to refresh这两项进行了修改

Arguments:
--no-color --source-map=$FileNameWithoutExtension$.css.map $FileName$

Output paths to refresh:
$FileNameWithoutExtension$.css:$FileNameWithoutExtension$.css.map


##### 在Webstorm中搭建自动化工作流：

（1）把Gruntfile.js和package.json文件放到项目目录中。
（2）file —- default setting —- node.js and npm  —- sources of node.js core modules
（3）在webstorm 的 terminal中npm install 安装上项目所有的依赖。


**前端自动化工具——grunt学习笔记**

##### 一、概述

前端团队代码风格不统一，如何强制开发规范。
前端开发的组件库如何维护和使用。
如何模块化前端项目。
服务器部署前必须的压缩等流程如何简化和完善。

主流的前端自动化解决方案有哪些？
yoeman + bower + grunt/gulp
codekit（只适用mac系统）
FIS
以及腾讯的Spirit（只适用移动端）

在linux下使用node命令行的话，得注意一下用户名是否含有空格。而空格会影响到一些命令行的顺利执行，所以如果你已经这样做了，可以新建一个账户来解决掉这个问题。

windows下的控制台无法执行bash脚本，所以推荐安装一个git bash shell。

npm install 命令后面没有指定安装什么时，会去查找当前所在目录下时否有package.json文件中有没有devDependencies指定依赖项，如果有，则会安装它们。

yeoman的作用——快速搭建现代web app的脚手架。

yeoman的安装：

	sudo npm install -g yo   #注意：苹果系统下要加sudo，Windows下的安装不用。下面的包安装也同样。

安装后可以执行yo -v查看安装的yeoman版本。

bower的作用——web的包管理器

bower的安装：

	sudo npm install -g bower

安装完之后，执行

	bower -v

grunt的作用——任务运行器，有强大的各种功能器件的支持

grunt的安装：

	sudo npm install -g grunt-cli  #注意别少了-cli

##### 二、yeoman实践

yeoman官网的generator列表中，前面有八字胡图标的generator是yeoman官方提供的，而没有这个图标的则是非yeoman官方出品的。

现在我门安装一个generator：

	npm install -g generator-angular

下面我们使用它：

	mkdir yo-in-action
	cd yo-in-action
	mkdir angular-in-action
	cd angular-in-action

因为使用angular generator会在当前文件下生成一个项目，所以我们给该项目先建立好一个文件夹angular-in-action
，然后进入到该文件中再去执行生成项目的命令。
下面我们执行用generator创建项目的命令。

	yo angular learangular

其中angular是生成器的名气，而learnangular是项目的名字，体现在在package.json文件内部的name项中，这并不是文件夹名。文件夹名是刚创建的angular-in-action。
然后接下来会问你是否需要用sass\bootstrap等，需要的话yes，不需要的话no
再接下来还会问你是否需要包含一些组件，可以按空格和方向键来依次选择和取消选择。

一些常见的bash命令行：

	pwd     #显示当前所在目录路径
	ls -al  #打印当前目录下所有文件及文件夹的列表
	rm -rf  #文件夹／文件名  删除文件／文件夹，-rf这个参数的意思是递归删除，且不需要二次确认。

下面看一下package.json这个文件：
dependenceis 是该项目发布后，用户在使用该项目时，需要安装的依赖文件。
devDependencies 是该项目开发过程中或者其它开发协作者在参与该项目的开发时，需要依赖的文件。
依赖项的内容以键值对的方式存在，例如：

	"grunt" : "^0.4.1"

^表示主版本号，是对版本的一个宽松的约定。就是说在该主版本号内的版本都是可以的。在我们执行npm install或者npm update的时候，如果发现有该主版本号之内的版本已发布，则会帮我们更新成最新版本。在这里，即只要是0.打头的grunt版本都是可以更新的，比如0.9.0，而如果出现了1.打头的版本，如1.0.0，则不会更新。
同样，还有

	"grunt" : "~0.4.1"

这里~的意思是，只对0.4.打头的版本进行更新，如0.4.2，而如果出现了0.5.0这样的版本，是不会更新的。

	"engines" : {
		"node": ">= 0.10.0"
	}
指定node的版本必须大于0.10.0：

	"scripts" : {
		"test" : "grunt test"
	}

这里指定的是在npm命令行中输入的命令与实际命令的对应关系。例如，这里是说当我们在控制台输入npm test的时候，实际执行npm grunt test。

##### 三、bower实践

	mkdir bower-in-action
	cd bower-in-action
	mkdir jquery-bootstrap-in-action
	cd jquery-bootstrap-in-action

	bower install jquery   #把jquery装上其最新稳定版本
	bower install bootstrap

http://bower.io/search 这个地址支持对所有的官网可获得的bower包的搜索。在其中输入jquery owner:jquery，可以搜索出所有jquery团队开发的包含jquery关键字的包。如果只输入jquery，则所有包含jquery关键字的包都会出现，不管它是不是jquery团队开发的。
如果你需要安装的是比较小众的包，而这个包在bower的库中没有怎么办呢？bower提供了其它的几种方式可供使用。
（1）通过github的短写安装，如

	bower install jquery/jquery

前面一个jquery是jquery在github上注册账号的名字，后一个jquery在github上项目的名字
（2）通过github完整的项目地址，如

	bower install https://github.com/jquery/jquery.git

（3）通过URL进行安装，例如

	npm install http://lib.sinaapp.com/js/jquery/1.7.2/jquery.min.js

在项目中设置一个bower.json文件之后，执行

	bower install

就会把其中定义的所有以来都安装好。要生成bower.json文件，只需要输入

	bower init

命令即可。
生成一个.bowerrc文件：
输入一个

	vim .bowerrc

命令
然后编辑其内容为：

	{
	"directory":"bower_coponents",                    //设置安装bower包的目录
	"proxy":"http://proxy.tencent.com:8080",         //用于配置代理
	"https-proxy":"https://proxy.tencent.com:8080",  //如果代理用的是https，则用这种方式配置代理
	"timeout":60000                                   //如果你的网络环境非常的差，可以设置一下timeout，其默认值是60000，单位时ms，你可以将其改为更长的时间，以便于安装或更新其中的依赖包的时候可以顺利安装。
	}


四、grunt实践

	npm install -g generator-webapp

	mkdir grunt-in-action
	cd grunt-in-action
	mkdir grunt-by-yo
	cd grunt-by-yo
	yo webapp grunt-by-yo

提示是否使用node-sass时选择no，因为这个工具目前还存在一些莫名其妙的问题，不是很好用。

在编辑器中打开当前项目。然后打开Gruntfile.js：

	'use strict';

	module.exports = function(grunt){
		require('time-grunt')(grunt);//这个模块用于记录任务花了多长时间运行，在我们优化项目build的时间时有用
		require('load-grunt-tasks')(grunt);//自动加载tasks

		//可配置的路径
		var config = {
			app:’app’,
			dist:’dist'
		};

		grunt.initConfig({
			config : config,  //像config这样的项，由于没有同名插件，对于这种没有通明插件的项，会被作为常量存储起来，在配置文件中以<%= %>这样的方式调用，如下文的<%= config.app %>
				   watch: {	  //而像watch这样的项，由于存在同名插件grunt-contrib-watch，这个插件在运行的时候，会直接读取Gruntfile.js中的同名项，然后根据其中的配置来运行。当然，要让grunt-contrib-watch插件运行，必须加载它，即grunt.loadNpmTask(‘grunt-npm-watch’)；但是，如果有很多任务需要加载的时候，一个个去加载他们显然有些费劲，因此就有人开发了一个工具，自动将package.json中所定义的依赖作为任务全部加载进来。即上文的require('load-grunt-tasks')(grunt);这一句。load-grunt-tasks就是这个工具的模块名字。

				bower: {
					files: ['bower.json'],
					tasks: ['wiredep']
				},
				js: {
					files:['<%= config.app %>/scripts/{,*/}*.js'],
					tasks: ['jshint'],
					options:{
						livereload:true
					}
				},
				jstest: {
					files: ['test/spec/{,*/}*.js'],
					tasks: ['test:watch']
				}
			}
		})
	}


其中的config : config, 除了这种方式，还有一种常用的方式如下 ：

	pkg : grunt.file.readJSON('package.json'),

就是把package.json中的所有配置读取进来，供后面以<%= pkg.***** %>的方式使用。

每一个task中又可以包含自己的options和target

比如，执行sass这一task下的dis这个target，则可以用命令行：

	grunt sass:dist

一个个的task可以组合在一起，组合在一起的组合任务还可以和其它的组合任务组合成更大的组合目录。

两种注册任务的方式：

	grunt.registerTask('某组合task的名字',function(target){
		grunt.task.run(['任务名'，'任务名','任务名']);
	})

或者

	grunt.registerTask('某组合task的名字',[
		'任务名',
		'任务名',
		'任务名'
	])



grunt 命令后面不跟任何参数的时候，会默认执行default这一组合task

常见的开源协议的宽松度比较：

MIT的宽松度>BSD> ISC> Apache> GPL

	npm init
	npm install grunt --save-dev    #在安装安装包的时候，加入--save-dev参数的话，意味着同时将其加入package.json的devDependencies项中；而如果只加 --save参数的话，意味着加入dependencies项中。

	npm install load-grunt-tasks --save-dev
	npm install time-grunt --save-dev
	touch Gruntfile.js

grunt 的文件拷贝依赖于官方的插件 grunt-contrib-copy，用如下命令行安装：

	grunt install grunt-contrib-copy —save-dev

grunt 中文件的删除则依赖于官方的插件 grunt-contrib-clean，用如下命令安装：

	grunt install grunt-contrib-clean —save-dev


下面一步步创建项目：

Gruntfile.js：

	'use strict';

	module.exports = function(grunt){
		require('time-grunt')(grunt);//这个模块用于记录任务花了多长时间运行，在我们优化项目build的时间时有用
		require('load-grunt-tasks')(grunt);//自动加载tasks

		//可配置的路径
		var config = {
			app:'app',
			dist:'dist'
		};


		grunt.initConfig({
			config : config,  //像config这样的项，由于没有同名插件，对于这种没有通明插件的项，会被作为常量存储起来，在配置文件中以<%= %>这样的方式调用，如下文的<%= config.app %>

			copy:{
				dist: {
					files:{
						'<%= config.dist %>/index.html' : '<%= config.dist %>/index.html',   //这里键值对的键是目标文件，值是源文件，值既可以是单个值，也可以是一个数组
						'<%= config.dist %>/js/index.js' : ［'<%= config.dist %>/js/index.js'］
					}
				},
				dist_js: {
					files:[
						{
							expand:true,
							cwd:'<%= config.app %>/', //注意：初学者经常忘记这里的/
							src:'*.html',
							dest:'<%= config.dist %>/',
							ext:'.min.js',
							extDot:'last', //表示从源文件命中的第一个点处开始修改文件的后缀，比如，源文件是index.max.js的话，目标文件会变成index.max.min.js。这个值还可以设置成first
							flatten: true, //flatten为true的话会直接把中间各层目录去掉，导致的结果是生成的文件在dist目录下，而且dist目录下的js目录被删除掉了。
							rename: function(dest,src){
								return dest + 'js/' + src;   //这样又可以将生成的文件放回dist的js文件夹下。它是在ext,extDoc,flatten等参数执行完之后才执行的。
							}
						}
					]
				}
			｝

			clean:{
				dist:{
					src:['<%= config.dist %>/**/*'],    //注意，一个＊表示匹配任意一个字符，但不包括反斜杠；两个＊表示匹配任意个数的任意字符，包括反斜杠。｛a,b}的形式则表示匹配a或者b。如果是！，则表示匹配取反。
					filter:'isFile'，  //filter的取值既可以是node.js的
					//fs.Status这个类下的函数名，包括isFile\isDrectory\isBlockDevice\isCharacterDevice\isSumbolicLink\isFIFO\isSocket，也可以是function(filepath){ return (!grunt.file.isDir(filepath)); } 这样的自定义处理函数。这里的设置是指删除文件，不删除文件夹的意思。
					dot: true, // dot为真的话，会命中以.开头的通明文件。比如，我们如果我们前面有设置匹配的是index.html文件话，那么如果设置了dot:true则会把.index.html也同时匹配上。
					matchBase:true, // 如果我们要匹配的是a?b，那么这里指的是可以匹配到／xyz/123/acb，但不会匹配到/xyz／acb/123
					expand:true, //意味着我们要处理动态的src到dest文件的映射。
				}
			}


			watch: {	  //而像watch这样的项，由于存在同名插件grunt-contrib-watch，这个插件在运行的时候，会直接读取Gruntfile.js中的同名项，然后根据其中的配置来运行。当然，要让grunt-contrib-watch插件运行，必须加载它，即grunt.loadNpmTask(‘grunt-npm-watch’)；但是，如果有很多任务需要加载的时候，一个个去加载他们显然有些费劲，因此就有人开发了一个工具，自动将package.json中所定义的依赖作为任务全部加载进来。即上文的require(‘load-grunt-tasks’)(grunt);这一句。load-grunt-tasks就是这个工具的模块名字。

				bower: {
					files: ['bower.json'],
					tasks: ['wiredep']
				},
				js: {
					files:['<%= config.app %>/scripts/{,*/}*.js'],
					tasks: ['jshint'],
					options:{
						livereload:true
					}
				},
				jstest: {
					files: ['test/spec/{,*/}*.js'],
					tasks: ['test:watch']
				}
			}
		})
	}

剖析grunt tasks —— grunt serve

	mkdir grunt-in-action
	cd grunt-in-action
	mkdir grunt-yo-webapp
	cd grunt-yo-webapp
	yo webapp grunt-yo-webapp

完成之后，查看Gruntfile.js可以看到关于serve这个task组合的配置。

下面开始对这个项目自动生成的Gruntfile.js进行解析：

我们在命令行中输入
	grunt serve
即可看到项目的浏览效果。而且如果我们在编辑器中修改页面的代码，动态地就可以展示到浏览器上，不用我们刷新浏览器。这是serve这个组合task帮我们自动完成的。如果在运行grunt serve命令的时候加上--allow-remote，则可以在局域网的其它机器上通过运行这个任务的机器的ip地址:9000/页面地址的方式访问到项目中的页面。

connect:dist:keepalive这个语句是什么意思呢？
对于task名:abc:def:ghi这样的语句，grunt会解析成
this.flags  { abc:true, def:true, ghi:true}
然后在执行任务的时候会去读取this.flags中的这些值。

wiredep这个task是用来根据bower.json的依赖文件来自动引入这些依赖的js和css文件到页面代码中。避免一个个手动去引入。

concurrent:server用来通过concurrent这个任务来指定server这一target并行执行。因为grunt中的任务默认是串行执行的。concurrent这个任务是用来让任务并行执行的。其中的server这一target从其源代码查看可知它是用来将sass编译成css，并拷贝到对应的输出目录。

因为webapp-generator生成的项目中使用了 sass，而sass依赖于ruby，所以用

	brew install ruby

命令先把ruby 安装上。然后用

	sudo npm install -g sass

把sass安装上。


---


<a name='js-angular'></a>
#### 第十二章 JavaScript之AngularJS


---


<a name='js-jade'></a>
#### 第十三章 JavaScript之Jade模版

	npm install jade -g
	jade -P index.html      #编译jade文件
	jade -P -w index.html      #当文件变化时实时编译jade文件

class用.，id用#，文本内容以空格分开，属性放在括号内，以等号连接属性名和属性值，属性之间以逗号隔开，例如：a#gotop.gotop(href='#',target='blank') back to top

如果文本内容很长，不想编译出来的内容都被压缩到一行上，可以在该文本内容之前加.然后把文本内容该分行的地方进行分行书写，以方便阅读。
例如:

	p.
	    1. aaa
	    2. bbb

或者在文本的每一行加上竖线和空格。例如

	p
	     | 1. aaa
	     | 2. bbb

##### jade中的条件语句：

（1）

	if
	elseif
	else

（2）

	unless

（3）
	case  变量名:
	when  '值':
	       p 这是第一语句
	when  '值':
	       p 这是第二语句
	when  '值':
	       p 这是第三语句
	default
	       p 这是默认语句

##### mixin的使用

先定义它：

	mixin mixin的名字
	        p  '这一行是mixin的内容'

再使用它：

	+mixin的名字

例子:

	mixin lesson
	        p  '这是个例子'
	+lesson

	mixin study(name,courses)
	       p  #{name} study
	       ul.courses
	       each course in courses
	                li = course
	+study('tom',['jade','java'])

	mixin group(student)
	     h4  #{student.name}
	     +study(student.name,student.courses)
	+group({name:'tom',courses:['jade','java']})

	mixin team(slogan)
	      h4 #{slogan}
	      if(block)
	            block
	      else
	            no team
	+team('slogan')
	      p good job!

##### 模板的引入

	include style    //把style.jade引入


---


<a name='js-node'></a>
#### 第十四章 JavaScript之node.js

##### 开启新纪元——进击node.js学习笔记（一）

node.js 的版本常识：
偶数版为稳定版本，基数版为非稳定版本。开发的话一定要使用稳定版本，即使用像0.6.x,0.8.x,0.10.x,0.12.x这样的版本。

mac系统下的node.js安装：

	xcode-select -p
	xcode-select --install
	python -V   #注意这里是大写的V
	ruby -v

打开brew.sh网站，把homebrew的安装语句

	ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"

拷贝到终端上执行它。

	brew install node

当然，也可以用homebrew来安装mogodb、git等等。语句为brew install mogodb git

	node -v


使用npm install -g n安装n模块，可以用n模块来安装指定的node版本和切换不同的node版本。比如，如果想安装0.10.33版本的node.js，就可以在终端中输入：

	n 0.10.33

安装完后，可以在终端中输入n，然后按向上或向下方向键来切换至你所需的node.js版本。

在终端中输入node所进入的执行环境与浏览器的控制台中所进入的环境是不一样的，一些顶层的对象会有区别。比如，在前者中输入process会打印出来该对象，在后者中输入window会打印出来该对象。但是，如果在前者中输入window或者在后者中输入process都会报错。

##### 如何用node.js建立一个服务器，提供调试AJAX请求的测试环境

首先来看怎样用node.js启动一个服务器。代码比较简单，如下所示：

	var http = require('http'); //  依赖一个用js写好了的http模块
	http.createServer(function(req,res){
		res.writeHead( 200, { 'content-type' : 'plain/text' } );
		res.end('Hello, node.js!\n');
	}).listen(1337,'127.0.0.1');


其中的

	function(req,res){
		res.writeHead( 200, { 'content-type' : 'plain/text' } );
		res.end('Hello, node.js!\n');
	}

是一个匿名的回调函数。指的是当监听到127.0.0.1的1337端口的访问后，用该匿名回调函数进行回调处理。

上面是用node.js启动一个服务器的基本操作。如果更进一步的话，我们可以修改它成一个突出jsonp数据的后台服务，用以提供前端开发时AJAX请求的测试环境。


	var http = require('http'),
		util = require('util'),
		url = require('url');
	http.createServer(function (req, res) {
		var myJsonpCallback = url.parse(req.url,true).query.callbackParam,//从访问地址中解析出来callbackParam的值
			responseData = {
				github:'paiangit',
				name:'paian'
			} ;//responseData是要发回客户端的json数据
		console.log('Request received: \n');
		console.log('从url中取得的参数值为' + myJsonpCallback +'\n');//打印出callbackParam这一URL参数的值
		util.log('Request recieved: \nmethod: ' + req.method + '\nurl: ' + req.url);
		res.writeHead(200, { 'Content-Type': 'text/plain' });
		req.on('data', function () {
			console.log('Data received!');
		});
		res.end(myJsonpCallback + '(' + JSON.stringify(responseData) + ')');
	}).listen(1337,'127.0.0.1');
	console.log('Server running on port http://127.0.0.1:1337/');


相应地，前台的AJAX请求可以这么写：

	$.ajax({
		url:"http://127.0.0.1:1337/",
		dataType:'jsonp',
		data:{
			'adata':adata   //这是随异步请求发送给服务端的某条数据，当然也可以不发送
		},
		jsonp:'callbackParam',
		jsonpCallback:"myJsonpCallback",
		/*这里的jsonp和jsonpCallback两个参数会组合成callbackParam=myJsonpCallback的形式附加在请求的URL后面。
		*上文中node.js代码的var myJsonpCallback = url.parse(req.url,true).query.callbackParam这一语句就是用来
		*获取所发来的请求的URL中的URL中callbackParam=myJsonpCallback的callbackParam参数的值的。
		*获得这个值之后会套在返回的json串外面，构成jsonp,实现跨域。服务端返回的数据格式是这样的:
		* myJsonpCallback({
		*	 github:'paiangit',
	    *    name:'paian'
		* })
		*/
		success:function(result){
			console.log('My github is' + result.github);
			console.log('And my name is' + result.name);
		},
		error:function(){
			console.log('Sorry, the request is playing a joke!')
		}
		timeout:3000
	});


---


<a name='canvas'></a>
#### 第十五章 JavaScript之Canvas

##### canvas实现星星闪烁特效

main.js

	var  can, ctx,
	girlPic = new Image(),
	starPic = new Image(),
	num = 60,
	stars = [],
	lastTime,
	deltaTime,
	switchy = false;

	function init(){
		can = document.getElementById('canvas');
		ctx = can.getContext('2d');
		w = can.width;
		h = can.height;

		document.addEventListener('mousemove',mousemove,false);

		girlPic.src = "src/girl.jpg";
		starPic.src = "src/star.png";

		for(var i = 0; i < num; i++){
			var obj = new starObj();
			stars.push(obj);
			stars[i].init();
		}

		lastTime = Date.now();
		gameloop();
	}

	document.body.onload = init;

	function drawBackground(){
		ctx.fillStyle = "#393550";
		ctx.fillRect(0,0,w,h);
	}

	function drawGirl(){
		//drawImage(img,x,y,width,height)
		//x粥坐标正方向向右，y轴正方向向下
		ctx.drawImage(img,100,150,600,300);
	}

	function mousemove(e){
		if(e.offsetX || e.layerX){
			var px = e.offsetX == undefined ? e.layerX  : e.offsetX;
			var py = e.offsetY == undefined ? e.layerY  : e.offsetY;
			// 我们约定，如果鼠标不在范围内，switchy= false；反之为true
			if( px > 100 && px <700 && p>150 && py<450){
				swichy =true;
			}
			else{
				switchy = false;
			}
		}
	}

	function gameloop(){
		window.requestAnimFrame(gameloop);

		var now = Date.now();
		deltaTime = now - lastTime;
		lastTime = now;

		//这里如果用console.log(deltaTime)将每次循环的时间间隔打印出来的话，会发现它是一个不断变化的值，这是由requestAnimationFrame所导致的。
		drawBackground();
		drawGirl();
		drawStars();
	}


	window.requestAnimFrame = (function(){
		return window.requestAnimationFrame || window.webkitRequestAnimationFrame ||  window.mozRequestAnimationFrame  || window.oRequestAnimationFrame ||  window.msRequestAnimationFrame  || function(callback,element){
			return window.setTimeout(callback,1000/60)
		}
	})();

	stars.js
	var starObj =  function(){
		this.x;
		this.y;

		this.picNo;
		this.timer;

		this.xSpd;
		this.ySpd;
	}

	starObj.prototype.init = function(){
		this.x = Math.random()*600 + 100; // Math.random()   的取值区间是 [0,1)
		this.y = Math.random()*300 + 150;

		this.picNo = Math.floor(Math.random()*7);
		this.timer = 0;

		this.xSpd = Math.random()*3 - 1.5; // [-1.5,1.5]
		this.ySpd = Math.random()*3 - 1.5;// [-1.5,1.5]
	}
	starObj.prototype.update= function(){
		this.x += this.xSpd * deltaTime * 0.004;
		this.y += this.ySpd * deltaTime * 0.004;

		// this.x超过范围，则重新生成
		if(this.x < 100 || this.x >700){
			this.init();
			return;
		}
		// this.y超过范围，则重新生成
		if(this.y<150 || this.y>450){
			this.init();
			return;
		}

		this.timer += deltaTime;
		if(this.timer > 50){
			this.picNo += 1;
			this.picNo %= 7;
			this.timer = 0;
		}
	}
	starObj.prototype.draw = function(){
		//drawImage(img, sx, sy, swidth, sheight, x, y, width, height)
		ctx.drawImage(starPic, this.x, this.y);
	}

	function drawStars(){
		for(var i = 0; i < num; i++){
			stars[i].update();
			stars[i].draw();
		}
	}


	function drawStar(){
		ctx.drawImage(starPic, 300, 400);
	}


---


<a name='optimization'></a>
#### 第十六章 前端优化技巧

##### 条件判断语句的优化

以下的表达式都返回false：

null

undefined

'' (空字符串)

0 (数字0)


以下的都返回true：

'0' (字符串0)

[] (空数组)

{} (空对象)

所有平时的写法 if(y != null && y != ''){} 可以写的更短些 if(y){}

下面的代码可以被三元运算符所替代：

	if(var != 0){
		return foo();
	}else{
		return bar();
	}

可以写成：

	return val ? foo() : bar();

&& 和 ||(oper2)这两个二元布尔操作符可以根据前面的代码判断后面的代码是否执行，“|| ”可以被称为默认操作符

	var win;
	if(opt_win){
	  win = opt_win;
	}else{
	  win = window;
	}

可替换为

	var win = opt_win || window;


---


<a name='tool'></a>
#### 第十七章 前端工具的使用

##### 调试神器之Charles抓包工具的使用：

在你进行调试的时候，可能需要把本地的某个javascript或css文件替换掉线上的某个页面中对应的javascript或css文件，进行在线调试。这时你就需要一个抓包替换工具。比如Windows系统下的fiddler。这里我讲一下Mac系统下的一个与fiddler类似的工具——Charles。

首先打开Charles工具，切换到sequence，刷新你要抓包的页面，可以抓到所有的请求。然后你找到你需要的替换的某个javascript或css文件，选中它右键单击，选择map url，然后选择本地的文件。然后点Charles中的刷新按钮，即可把该请求指向本地的资源。这样可以方便地进行调试。

##### host绑定的处理

控制台中输入sudo vim /etc/hosts，回车，然后输入机器密码。看到打开的hosts文件，按shift + i键进行输入，把要绑定的host粘贴到hosts文件的末尾。然后按esc退出编写模式。再按shift + : 。之后再输入:wq，进行保存和退出。如果只是退出而不保存，则应输入:x，然后回车进行退出。

##### Webstorm怎么设置让编码自动换行？

view - active editor — use soft wraps

##### TMS工具的使用

TMS是一个PHP模板编辑工具，其中中遇到的坑如下：

（1）JavaScript中的反斜杠要进行转意才有效，即\\来表示代码中的一个反斜杠。

（2）div标签未闭合导致的offsetTop获取不准确的问题。因为改变了元素的层级关系，这样其父元素就变了，如果这个副元素恰好有定位的好，那就导致获取的offsetTop可能是其相对于这个有定位的错误父元素的，而不是预想中的那个元素的。

（3）英文等号打成中文的等号，会导致 class="某class名" 这里的某class样式不会被渲染，看起来样式名也有，就是加载不进来这样的奇怪问题。

（4）在预发布中的一些所谓问题，正式发布后就可能不存在了。所以不要相信预发布中的预览效果。

（5）引入了其它样式时，需要考虑是不是别的样式覆盖了当前设定的样式，比如，明明设置了微软雅黑字体，却还是显示成了别的字体，这就需要考虑下是不是引入的样式被覆盖掉了。

（6）如果出现开发中要引入页头或页脚，而其中又包含一些公共样式的时候，最好一开始就将他们引入，以免最后合并的时候才发现reset样式不一样，导致一些覆盖问题，再去解决就会比较麻烦。

（7）在遇到不好解决的问题时，查看一下源代码，看看符号是否有全角半角、中文英文错设的情况，看看有无完整闭合标签等，可能会解决掉一些奇怪的问题。

（8）在html标准中，遇上双引号和单引号嵌套不够用时，可以对引号字符进行转意。

（9）在使用if else语句时

      <? } ?>
      <? else { ?>

      这种写法会报语法错误，需要改成：

      <? }
      else { ?>

      才可以运行通过。

（10）给cnzz埋点时，需要注意onclick="_czc.push(['_trackEvent','导航','xxxx']);" 中的双引号不能少，否则在ie6-8中会报错。

（11）关于charset="utf-8"这样的meta设置，在tms模版中优先级是低于tms中后端服务器报头中编码格式的设置的，所以在编写TMS时，就不用设置charset="utf-8"。因为TMS后端在报头中设置的返回浏览器的编码的格式为gbk。

##### png8-data-uri的使用

首先需要安装brew，安装命令请从其官网复制过来：http://brew.sh/ 。

然后要安装libpng


---


<a name='component'></a>'

#### 第十八章 前端插件或组件的开发

##### 非插件或组件化的javascript文件写法——;(function(window,undefined){})(window)的理解

对于一个非插件或组件化的javascript文件，其常见写法为：

	;(function(window,undefined){
		// do something here
	})(window)

为什么要写得这么绕呢？这是很多新入行的同学所困惑的问题。

首先，为什么要把window对象作为参数传入进去呢？
主要原因如下：
window是DOM对象模型的最顶层对象。ECMA Script在执行function(){}内部的语句时，每次执行一句跟window对象相关的语句都要去外层找一遍window对象，而如果把window对象作为变量传入进去，那么就可以直接访问到。这种速度要比去外层找window对象要快。有人写了如下这两段代码来检测传入window对象与不传入该对象在执行效率上的不同：

	var num = 10000;
	// 代码1
	(function(window, undefined){
	    var a1 = new Date();
	    for (var i = 0; i < num; i++) {
	        document.write(window["pp" + i]);
	    }
	    var a2 = new Date();
	    alert(a2.getTime() - a1.getTime());
	})(window);
	// 代码2
	(function(undefined){
	    var a1 = new Date();
	    for (var i = 0; i < num; i++) {
	        document.write(window["pp" + i]);
	    }
	    var a2 = new Date();
	    alert(a2.getTime() - a1.getTime());
	})();

通过在浏览器的控制台中执行它们，可以清晰地看出执行这两段代码的效率上的区别：前者明显比前者执行的时间更短。

其次，为什么外面传入的只有window这一个参数，而里面却有两参数呢（多了个undefined）？
 一方面，undefined在JavaScript中并不属于保留字/关键字，因此在ie5.5-ie8中我们可以将其当作变量那样对其赋值（IE9+及其他现代浏览器中赋值给undefined将无效），也就是说undefined 在ie5.5-ie8等浏览器中是可以作为变量名而赋予其它值的。这样，它就有可能被人修改成其它的值。所以需要将undefined的值在我们的程序范围内重置回undefined，以保证不受到外界的影响。如何重置呢？实参不传入内容，而形式参数是undefined的情况下，因为实参未定义，所以形式参数undefined获得的值就是undefined。
另一方面是因为在一些老浏览器中直接使用undefined会报错，考虑到兼容性，因此使用未定义实参的方式来生成一个undefined值传给内部的形式参数undefined。这样，在其内部再使用undefined的时候，就不会报错了。此外要注意，不要把window.undefined作为实参传递给形参，因为window.undefined可能被其他人修改了。所以最好的方式就是什么都不传，那样形参的undefined就会因实参未定义而成为真正的undefined了。


##### 组件开发

给css加前缀形成命名空间。避免组件的css命名冲突。有的人采用前面都加个父类选择器的方式来避免命名冲突，这实际上是把css和html结构耦合在了一起，同时也会导致嵌套很多，是不可取的方式。

js通过匿名函数隔开公有和私有空间。然后通过window.tabView=tabView;的方式把组件对象挂到window这个全局对象上，从而完成其对外的暴露。

模块化：
模块名就是js文件名（不含后缀）。
模块文件的写法如下：
define(['所依赖的模块名'],function(m1){
      return{
            a:3,
            b:5
      }
})

原生弹窗的问题：1、阻塞进程，2、不同浏览器样式不同，3、不可自定义样式。

如果require中未未指明模块对应的文件名，则默认依赖的模块名即是文件名。如果要指定，可以通过配置paths，如下所示：

require.config({
         paths:{
                 jquery:'jquery-1.11.0.min'
         }
})

在构造函数中添加this.config={}进行配置。然后用构造函数.prototype={
     函数名:function(cfg){
             var CFG=$.extend(this.cfg,cfg);//进行配置项合并，把cfg参数中的配置合并进构造函数中的配置项中，如果与构造函数中的配置项同名的话则会覆盖掉构造函数中的配置项。
     }
}

皮肤的定制:
采取在css中写好多套皮肤，在js中传入控制皮肤的classname来进行定制。可以很好地处理在同一页面中该组件使用了多次，且使用了多个皮肤的问题。

定制按钮文案：

在配置项中设置text4button的默认值，在调用组件时传入该参数修改默认值。
依赖jQueryUI后，jQuery对象会增加一些方法，如draggable方法。

在配置项中增加dragHandle=null来设置默认拖动的把手为空。然后调用时传入一个元素作为参数进行把手指定。
在代码内部，判断是否传入了把手参数，如果有传入，则把它写进draggable方法的参数中。如果没有传入，则draggable方法不填参数，默认会拖动整个调draggable方法的对象。
utility抽象类是和ui无关的，像drag、resize、ajax、动画,wiget抽象类是和ui有关的，像tabview,treeview。


---


<a name='others'></a>
#### 第十九章 前端杂物间

对页面进行放大时（即显示比例大于100%），同一宽度的线段接口处可能出现水平方向更宽，垂直方向更窄，且略微有错位的情况。按ctrol(或command)+0键恢复成100%的比例即可消失该问题。

使用带有 http-equiv 属性的 <meta> 标签时，服务器将把名称/值对添加到发送给浏览器的内容头部。例如，添加：

	<meta http-equiv="charset" content="iso-8859-1">
	<meta http-equiv="expires" content="31 Dec 2008">

这样发送到浏览器的头部就应该包含：

content-type: text/html
charset:iso-8859-1
expires:31 Dec 2008

jar文件无法打开的处理办法？

先下载安装jdk：http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html

然后下载安装wget：

wget工具for Mac

（1）下载zip包Download;

http://files.cnblogs.com/kiss007/wget-1.13.4.tar.gz.zip

（2）解压到到Mac系统根目录,生成"wget-1.13.4.tar.gz"文件;

（3）打开终端;

（4）输入:

	tar zxvf wget-1.13.4.tar.gz

	cd wget-1.13.4

	sudo ./configure --with-ssl=openssl

	sudo make

	sudo make install

成功测试:进入刚刚安装的目录用cd命令。输入:

	wget www.baidu.com

有人说，后来才发现问题关键在于 中文目录！ 如果同样有下载jar文件的朋友请尽量不要把jar文件放在自己新建的中文目录下。（系统自带文件夹无妨）。把文件所在子目录改成英文就可以正常启动了，与jdk没有太大关系。另外java设置没有是因为我装了好几次jdk的环境后没有重启（不知道是不是个别原因），我是重启后能在偏好设置里找到了。

最新版wget在macbook air 的jdk1.8中无法安装，可能原因是它是用jdk1.6打的jar包。

那些踩过的坑：

（1）误以为对象有length属性，其实对象是没有length属性的
所以在获取json对象的长度的时候，不能直接用length，而要用
for(var key in obj){
	if(obj.hasOwnProperty)
}

（2）动态添加的元素或动态修改的class上绑定事件失效的问题
即错误地采用.click(function(){}) 、.on('click',function(){}这样的方式来对动态生成的元素或动态生成的class上绑定元素。这样的绑定方法只对页面中一开始就有的元素的事件的绑定是有效的。
还有人采用.live(click,function(){})的方式，这在老版本的jQuery中是有效的，但是live() 方法在 jQuery 版本 1.7 中被废弃了,在版本 1.9 中被移除了。所以，最新版本的jQuery显然是无法继续使用live了。
正确的做法应该是采用delegate：
$('.foldAndUnfoldWrap').delegate('.fold','click',function(){
	//do something
})
$('.foldAndUnfoldWrap').delegate('.unfold','click',function(){
	//do something
})

（3）使用ajaxfileupload插件时，$.ajaxFileUpload({
			....
			success : function(data, status){
				var result = JSON.parse(data),
			}
JSON.parse语句在Mac系统的firefox 37.0.2版本中报错说data格式不对，最后发现是因为该data 的末尾被迅雷的插件附加了一个div元素的 html，导致它已不再是json格式，从而JSON.parse(data)时解析出错。最后把这个插件删除了，重启一下该浏览器，就好了。

###第二篇 体悟篇

1. [地铁胡思](#railway-think '地铁胡思')



---


<a name='railway-think'></a>
####地铁胡思

（1）任性时请注意：如果你可以欣然地去做一件并非天然想做的事情，这就是你与过去的那个你不同的开始，你可以称之为超越或者胸怀。反之，那是一种原地踏步的任性。

（2）抱怨时请注意：认清所处的大环境，发现它的好，也接受它的不好，是喜欢上自己所做的事情的开始。消极和积极，是一念之间。积极面对那些不好，它们是一种考验。消极面对那些不好，它们是种二次伤害。环境跟人一样，各有各的身不由己。那些不完美很可能是它的身不由己。比如说互联网行业的快节奏——不快一个组织就难以在其中存活下来。

（3）势力时请注意：每一个你看起来卑微或不屑的人都值得拥有你同样的尊重，人是会变的，时间是最好的治疗。尊重与讨好截然不同。尊重所有人，并不是讨好所有人。讨好所有人，等于令所有人都讨厌。

（4）幸或不幸时请注意：幸运和不幸绝对是种偶然，不要把它当必然。享受幸运，忘记不幸，是把幸运最大化、不幸最小化的基本方法。

（5）任性时请注意：如果你可以欣然地去做一件并非天然想做的事情，这就是你与过去的那个你不同的开始，你可以称之为超越或者胸怀。反之，那是一种原地踏步的任性。

（6）抱怨时请注意：认清所处的大环境，发现它的好，也接受它的不好，是喜欢上自己所做的事情的开始。消极和积极，是一念之间。积极面对那些不好，它们是一种考验。消极面对那些不好，它们是种二次伤害。环境跟人一样，各有各的身不由己。那些不完美很可能是它的身不由己。比如说互联网行业的快节奏——不快一个组织就难以在其中存活下来。

（7）势力时请注意：每一个你看起来卑微或不屑的人都值得拥有你同样的尊重，人是会变的，时间是最好的治疗。尊重与讨好截然不同。尊重所有人，并不是讨好所有人。讨好所有人，等于令所有人都讨厌。

（8）幸或不幸时请注意：幸运和不幸绝对是种偶然，不要把它当必然。享受幸运，忘记不幸，是把幸运最大化、不幸最小化的基本方法。

（待续）