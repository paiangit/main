《拍岸集》
======================
人生如棋 落子无悔（代序）
----------------------
<br>
我喜欢诗词，喜欢诗意的语言中所传达出的人生状态和体悟。当要给自己取个花名的时候，我首先想到的就是诗词。我想给自己取一个如繁星、春水那般“诗意”的名字。最终，我选定苏东坡《念奴娇·赤壁怀古》中“惊涛拍岸卷起千堆雪”一句的“拍岸”两字作为花名，通过惊涛拍岸虽百折而仍不思回的自然景观以及谈笑间樯橹灰飞烟灭的历史画卷，传达我对大气磅礴、热情奔放、智慧洒脱之人生状态的向往。因此，我的技术博客文集，也就取名为*《拍岸集》*。名字虽然响亮，但其内容却未必能与之相称，因而我也倍感惶恐。不过，我又劝自己，既然只是记录屌丝追寻历程中点点滴滴的博文，则自己喜欢便好。各位看官如若看不惯，且当在下是年少轻狂的“怪蜀黍”可好？
<br>

程序语言与诗词语言是截然不同的。前者是严谨的，后者则要随性得多。因此，一个喜欢诗词的人要去写程序，必须经过一个痛苦的过程。这就好像练葵花宝典——“欲练此功，必先自宫”。但即便自宫，也未必能够成功。是的，入行成为一个程序员是有代价的。
<br>

回想起，十多年前开始接触程序，到现在以程序开发为职业，这中间实在是一个漫长的过程。在这个过程中，我花费了许多美好的日子埋头在幽暗的屋子里与电脑对话，包括无数个诱人的周末和夜晚。选择了成为一名程序员，不管是做前端开发还是后端开发，都意味着你需要能忍受经常不得不终止与家人的闲聊，关掉正在热播的影视节目，拒绝窗外春暖花开、夏荷带雨、秋叶飘零、冬雪纷飞的诱惑，静下心来，把精力集中到API文档的阅读、概念的理解、逻辑的梳理、架构的搭建、代码的编写等枯燥的事情中去。久而久之，当你忽然某一天偶得空闲，重新回到灿烂的阳光下时，习惯了长期呆在室内的你会发现，自己对日光是那样的不适应，以致于眉头紧锁，眉心有日积月累的深深皱纹，甚至此时你还有些头晕。那就对了。这就是把青春付与程序的代价！
<br>

当然，与失去相伴而来的，是获得。你从啃老一族慢慢变得可以自给自足，从浮躁轻率变得理智严谨，从浮想联翩变得脚踏实地。你可能从小白走向了leader岗位，从光棍一条变得拖家带口，甚至可以骄傲地和偶遇的陌生人说：你用的这个软件是我们公司开发的，我在其中担任某某角色！
<br>

每一个收获，都如同辛劳一天后回家吃到的一块小甜点，未必能让你一天的辛劳烟消云散。你可能会说：看起来收获并不那么多，代价却很高啊！我所能告诉你的是，收获每个人都不一样，难以一一尽述，而代价却大体相同，那就是牺牲诸多美好时光。可是，你要知道，每个人都需要作出选择，任何事情都是有代价的，而每个人选择的能力也千差万别，所以选择的对与错也便难有统一的标准。人非圣贤，谁能总是做出正确的选择？你唯一需要考虑的，是在你力所能及的范围内权衡代价与获得，看这样的付出对你来说是否值得，是否愿意。不愿意的话便要及时调整方向，勿要在犹犹豫豫中痛苦度日。一旦选好了就认真走下去，像惊涛拍击岸崖一般，纵然被击成细碎的浪花干涸在岸崖上，亦应无悔。至于最后能否成功，有句歌词唱得好，“三分天注定，七分靠打拼，爱拼才会赢”。机遇难以揣摩，打拼自己可控。多一份努力，便多一线成功的希望。打拼过后，即便失败了，也留一个畅快淋漓的人生过程！而这，也是对生命力的最好诠释。如果生命像一滩死水，活着还有什么劲儿？
<br>


##目录

###第一篇 技术篇

1. [那些我们常犯的基本错误](#normal-error '那些我们常犯的基本错误')

2. [Git的使用简介](#git 'Git的使用简介')

3. [MarkDown语法简介](#markdown 'MarkDown语法简介')

4. [CSS之重置样式](#css-reset 'CSS之重置样式')

5. [CSS之常见兼容性问题总结](#css-compatibility 'CSS之常见兼容性问题总结')

6. [CSS之高级布局](#css-layout 'CSS之高级布局')

7. [CSS3之动画实现](#css-animation 'CSS3之动画实现')

8. [JavaScript之基础知识理解](#js-base 'JavaScript之基础知识理解')

9. [JavaScript之常用JavaScript代码段](#js-segment 'JavaScript之常用JavaScript代码段')

10. [JavaScript之自动化工作流](#js-workflow 'JavaScript之自动化工作流')

11. [JavaScript之AngularJS](#js-angular 'JavaScript之AngularJS')

12. [JavaScript之Jade模版](#js-jade 'JavaScript之Jade模版')

13. [JavaScript之node.js](#js-node 'JavaScript之node.js')

14. [前端性能优化技巧总结](#optimization '前端性能优化技巧总结')

15. [前端工具的使用] (#tool '前端工具的使用')
<br>

<a name='normal-error'></a>
#### 那些我们常犯的基本错误

##### 那些常见的发音错误

在日常工作中，读错一个单词也许算不得什么。但是，如果你去一个几百人、几千人甚至更大的场合做一个分享，而其中出现英文单词发音错误的问题，会降低你所做分享的专业性和信服力。下面我总结了一些曾犯过的基本发音错误：

浏览器safari曾被我多年自以为是地误读为[ˈsæfəri]，而很多人也跟我一样读。直到有一次听人讲课，发现它的发音和我不一样。我半信半疑地查了下字典，才发现我是错的。正确发音应该为：英音 [səˈfɑ:ri]  美音 [səˈfɑri]

<a name='git'></a>
#### Git的使用简介

##### Windows系统中Git的使用

在控制台中输入
d:
mkdir paiangit
git clone https://github.com/paiangit/main.git
出现错误提示如下：

>'git' 不是内部或外部命令，也不是可运行的程序或批处理文件。

这时我们首先得检查是否安装了git，如果没有，则得先去 http://git-scm.com/download/win 中下载windows版的git并安装它。我这里选择安装在D:\Program Files目录下。

其次，需要查看一下系统中的环境变量是否对git的路径进行过添加。具体的添加做法是，在“我的电脑”图标上单击右键——选择“属性”——选中“高级”选项卡——单击其中的“环境变量”按钮——在下侧的系统变量中找到Path变量，双击它——把下列路径添加到该变量的最后。

;D:\Program Files\Git\bin;D:\Program Files\Git\libexec\git-core;

其中的D:\Program Files\改成你的Git安装路径即可。

然后重启控制台（注意，改完环境变量后要重启控制台才会生效），在控制台中输入
d:
cd paiangit
切换回d:/paiangit目录，重新试一下 git clone https://github.com/paiangit/main.git
这下就可以成功clone项目到本地了。

然后用 git checkout daily/1.0.0 切换到我在github上已经创建好的分支daily/1.0.0上。

接下来用webstorm打开d:/paiangit目录，对其中的内容进行编辑。比如，我们可以打开README.md文件，用MarkDown语法编辑其中的内容。MarkDown语法怎么用，我在下一节的内容中会讲到。

在对README.md文件编辑完成后，用git status命令查看一下状态，会在控制台中出现哪些文件进行过更新的信息。

下面就需要用命令对更新过的文件进行提交了。

<pre>
git add README.md                                #添加对README.md的监控
git commit -m '增加了git在windows中的使用'       #提交到本地
这时会弹出如下信息：
*** please tell me who you are
这时候，你需要提供你的用户名和邮箱，以便其确认你的身份。命令如下：
git config user.name 你的github用户名
git config user.email 你的github邮箱
</pre>

最后再push到远程上：
<pre>
git push origin daily/1.0.0                      #push到远程
</pre>

输入完这上一行命令后，会提示你输入用户名和密码，按要求输入即可。密码在输入时什么提示也没有，你可能感觉没有输入成功。这时你不用担心，只要认真输入完成，回车即可。如果输入是正确的，就可以完成push到远程的操作了。

（下面这段有问题，现在还未实现。
但是，多提交几次你就会发现，每次都要你输入用户名和密码，是不是很麻烦啊？下面告诉你一个简单的方法，用SSH公钥来进行认证。
打开控制台，在默认的目录下（一般是C:\Documents and Settings\Administrator\）输入dir命令，查看该目录下有哪些文件夹和文件。在其中找一找有没有.ssh这个文件夹。如果没有，则切换到C:\Documents and Settings\Administrator\或者D:\Documents and Settings\Administrator\中找一找有没有该文件夹。找到该文件夹后，用cd .ssh切换到该文件夹下。
然后输入如下命令进行公钥和秘钥的生成。
ssh-keygen -C 你的email地址  -t rsa
然后会提示你输入保存秘钥的地址，你直接输入id_rsa即可将公钥保存到.ssh目录下的id_rsa.pub文件中，而秘钥则在相同目录下的id_rsa中。
然后用cat id_rsa.pub命令将该公钥文件的内容打印到控制台中，复制其中不包含email地址的部分。
在github网站上登录进去，单击右上角的小齿轮进入到settings菜单，选中左侧的SSH Keys菜单项，单击右上方Add SSH Key按钮，把刚才复制好的SSH公钥粘贴进去。
title可以随便取。
然后重启一下控制台。这样，下次进行push时就不用再输入用户名密码了。）


##### Mac系统中Git的使用

常用命令及其意义如下：

<pre>
mkdir paiangit                   #创建一个目录paiangit

git init                         #初始化一个项目

git config user.name paiangit    #设置访问该目录的账户名

git config user.email xxx@xx.xx  #设置访问该目录的账户邮箱

pwd                              #显示当前目录的完整路径

rm -rf xxx                       #删除某某文件或文件夹

mkdir paiangit                 #创建目录 paiangit

ls                               #查看当前目录下文件

cd paiangit                    #切换到目录paiangit

cd ..                            #返回到当前目录的上一级目录

clear                            #清屏

git status                       #查看有变化的文件(一般有变化的文件会以红色显示出来)

git clone https://github.com/paiangit/main.git   #拷贝一个项目到本地

git checkout -b daily/1.x.x      #在现在分支上创建一个新分支

git checkout daily/1.x.x         #切换到这个分支

git add -A                       #stages all

git commit -m '提交的备注信息'     #先add 再提交修改

git push origin daily/1.x.x      #把内容推送到日常环境

git tag publish/1.x.x            #打个tag

git push origin publish/1.x.x    #把这个tag的版本发布到正式线上

git pull origin daily/1.x.x      #拉取最新代码

git rm --cached -r right.css.map  #移除文件right.css.map的缓存

git diff                          #查看修改的详细内容

git diff  cached
</pre>

##### git使用了错误的邮箱push过，如何恢复它？

在使用git时push一直不成功，git log 中发现 xxx@xxx.xxx 邮箱非法，请务必使用公司邮箱.
请先使用如下命令行设置正确git提交信息:
<pre>
git config --global user.name 'xxxx'&&git config --global user.email 'xxx@xxx.com'
git-m
</pre>
后面一个指令使用了git-m命令修改log信息,获得git-m方法：

Linux(Redhat): sudo yum install git-m -b test -y

Windows: 在msysgit的命令行中运行curl http://openbase.cn-hangzhou.oss.aliyun-inc.com/git-m -o git-m

Mac/Ubuntu: wget http://openbase.cn-hangzhou.oss.aliyun-inc.com/git-m  && sudo chmod 775 git-m && sudo mv git-m /usr/bin/

再输入
<pre>
git-m
</pre>

<a name='markdown'></a>
#### MarkDown语法简介

MarkDown的基本语法如下：
（1）标题设置
在Markdown当中设置标题，有两种方式：
第一种：通过在文字下方添加一排“=”和“-”。文字下面加一排“=”表示一级标题；文字下面加一排“_”表示二级标题。
第二种：在文字开头加上 “#”，通过“#”数量表示几级标题。（一共只有1~6级标题，1级标题字体最大。文字前面加了几个“#”就表示是几级标题。比如#aaa表示aaa是一级标题，##bbb表示bbb是二级标题。以此类推。）

（2）块注释（blockquote）
通过在文字开头添加“>”表示块注释。

（3）斜体
将需要设置为斜体的文字两端使用1个“*”或者“_”夹起来

（4）粗体
将需要设置为斜体的文字两端使用2个“*”或者“_”夹起来

（5）无序列表
在文字开头添加(*, +, and -)实现无序列表。但是要注意在(*, +, and -)和文字之间需要添加空格。（建议：一个文档中只是用一种无序列表的表示方式）

（6）有序列表
使用数字后面跟上英文句号和一个空格。

（7）链接（Links）
Markdown中有两种方式，实现链接，分别为内联方式和引用方式。
	内联方式：This is an [example link](http://example.com/).
	引用方式：
	I get 10 times more traffic from [Google][1] than from [Yahoo][2] or [MSN][3].

	[1]: http://google.com/        "Google"
	[2]: http://search.yahoo.com/  "Yahoo Search"
	[3]: http://search.msn.com/    "MSN Search"

（8）图片（Images）
图片的处理方式和链接的处理方式，非常的类似。
	内联方式：![alt text](/path/to/img.jpg "Title")
	引用方式：
	![alt text][id]

	[id]: /path/to/img.jpg "Title"

（9）代码（HTML中所谓的Code）
实现方式有两种：
第一种：简单文字出现一个代码框。使用`<blockquote>`。（`不是单引号而是左上角的ESC下面~中的`）
第二种：大片文字需要实现代码框。使用Tab和四个空格。

（10） 脚注（footnote）
实现方式如下：
	hello[^hello]


	[^hello]: hi

（11）下划线
在空白行下方添加三条“-”横线。（前面讲过在文字下方添加“-”，实现的2级标题）

<a name='css-reset'></a>
#### CSS之重置样式

<a name='css-compatibility'></a>
#### CSS之常见兼容性问题总结

##### CSS Hack的使用

了解几个基本的CSS Hack是必要的。虽然使用它们之前，最好先尝试别的办法，实在不行再使用浏览器检测和CSS Hack。下面是几个最基本的：

_property:value; —— (for IE6)
*property:value; —— (for IE6 和 IE7)
property:value\9; ——(for IE6、IE7、IE8和IE9)

CSS Hack书写顺序为：先写非IE浏览器所需样式，其次写IE8/9所需样式，接着是IE7的，再接着才是IE6的。
使用示例：
<pre>
.container{
	width:300px;
    height:32px;
    background-color:#aaa;/*所有浏览器识别*/
    background-color:#bbb\9; /*IE6、7、8、9识别*/
    *background-color:#ccc;/*IE6、7识别*/
    _background-color:#ddd;/*IE6识别*/
}
</pre>
值得注意的是，随着浏览器版本的变化，曾经可用的一些Hack也在失效。所以，建议大家要用的话就只用*和_这两个目前来说比较稳定的Hack，其它的就尽可能不要用了。实在有不好解决的兼容问题，就用如下浏览器条件注释来判断，然后引入对应的CSS来解决吧。

	<!--[if IE]> 所有的IE可识别 <![endif]-->

	<!--[if IE 9]> 仅IE9可识别 <![endif]-->

	<!--[if IE 8]> 仅IE8可识别 <![endif]-->

	<!--[if lt IE 8]> IE8以下版本(不含IE8)可识别 <![endif]-->

	<!--[if lte IE 7]> IE7以及IE7以下版本可识别 <![endif]-->

	<!--[if IE 7]> 仅IE7可识别 <![endif]-->

	<!--[if IE 6]> 仅IE6可识别 <![endif]-->

对于非IE浏览器，基本上所有的兼容问题，都是不应该用Hack的方式来解决的。

##### CSS中的单冒号（:）和双冒号（::）的区别

在CSS3中，有:与::的写法经常让人“傻傻分不清楚”。比如，像:before与::before，它们之间到底有什么区别呢？
一言以蔽之，单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。其中，双冒号是在当前规范中引入的，用于区分伪类和伪元素。不过浏览器需要同时支持旧的已经存在的伪元素写法（即单冒号的写法），比如:first-line、:first-letter、:before、:after等。也就是说，对于CSS2之前已有的伪元素，比如:before，单冒号和双冒号的写法::before作用是一样的。

所以，如果你的网站只需要兼容webkit、firefox、opera等浏览器，建议对于伪元素采用双冒号的写法，因为它是最新标准。但如果不得不兼容IE浏览器，还是用CSS2的单冒号写法比较安全。

<a name='css-layout'></a>
#### CSS之高级布局

<a name='css-animation'></a>
#### CSS3之动画实现

<a name='js-base'></a>
#### JavaScript之基础知识理解

<a name='js-segment'></a>
#### JavaScript之常用JavaScript代码段

##### history的前进与后退
<pre>
history.back(0);  //刷新
history.back(1);  //前进
history.back(-1); //直接返回当前页的上一页，数据全部被清空，是个新页面
history.go(-1);   //也是返回当前页的上一页，不过表单里的数据全部还在
</pre>

<a name='js-workflow'></a>
#### JavaScript之自动化工作流

**前端自动化工具——grunt学习笔记**

##### 一、概述

前端团队代码风格不统一，如何强制开发规范。
前端开发的组件库如何维护和使用。
如何模块化前端项目。
服务器部署前必须的压缩等流程如何简化和完善。

主流的前端自动化解决方案有哪些？
yoeman + bower + grunt/gulp
codekit（只适用mac系统）
FIS
以及腾讯的Spirit（只适用移动端）

在linux下使用node命令行的话，得注意一下用户名是否含有空格。而空格会影响到一些命令行的顺利执行，所以如果你已经这样做了，可以新建一个账户来解决掉这个问题。

windows下的控制台无法执行bash脚本，所以推荐安装一个git bash shell。

npm install 命令后面没有指定安装什么时，会去查找当前所在目录下时否有package.json文件中有没有devDependencies指定依赖项，如果有，则会安装它们。

yeoman的作用——快速搭建现代web app的脚手架。

yeoman的安装：
	sudo npm install -g yo   #注意：苹果系统下要加sudo，Windows下的安装不用。下面的包安装也同样。
安装后可以执行yo -v查看安装的yeoman版本。

bower的作用——web的包管理器

bower的安装：
	sudo npm install -g bower
安装完之后，执行
	bower -v

grunt的作用——任务运行器，有强大的各种功能器件的支持

grunt的安装：
	sudo npm install -g grunt-cli  #注意别少了-cli

##### 二、yeoman实践

yeoman官网的generator列表中，前面有八字胡图标的generator是yeoman官方提供的，而没有这个图标的则是非yeoman官方出品的。

现在我门安装一个generator：
	npm install -g generator-angular

下面我们使用它：
	mkdir yo-in-action
	cd yo-in-action
	mkdir angular-in-action
	cd angular-in-action
因为使用angular generator会在当前文件下生成一个项目，所以我们给该项目先建立好一个文件夹angular-in-action
，然后进入到该文件中再去执行生成项目的命令。
下面我们执行用generator创建项目的命令。
	yo angular learangular
其中angular是生成器的名气，而learnangular是项目的名字，体现在在package.json文件内部的name项中，这并不是文件夹名。文件夹名是刚创建的angular-in-action。
然后接下来会问你是否需要用sass\bootstrap等，需要的话yes，不需要的话no
再接下来还会问你是否需要包含一些组件，可以按空格和方向键来依次选择和取消选择。

一些常见的bash命令行：
	pwd     #显示当前所在目录路径
	ls -al  #打印当前目录下所有文件及文件夹的列表
	rm -rf  #文件夹／文件名  删除文件／文件夹，-rf这个参数的意思是递归删除，且不需要二次确认。

下面看一下package.json这个文件：
dependenceis 是该项目发布后，用户在使用该项目时，需要安装的依赖文件。
devDependencies 是该项目开发过程中或者其它开发协作者在参与该项目的开发时，需要依赖的文件。
依赖项的内容以键值对的方式存在，例如：
	"grunt" : "^0.4.1"
^表示主版本号，是对版本的一个宽松的约定。就是说在该主版本号内的版本都是可以的。在我们执行npm install或者npm update的时候，如果发现有该主版本号之内的版本已发布，则会帮我们更新成最新版本。在这里，即只要是0.打头的grunt版本都是可以更新的，比如0.9.0，而如果出现了1.打头的版本，如1.0.0，则不会更新。
同样，还有
	"grunt" : "~0.4.1"
这里~的意思是，只对0.4.打头的版本进行更新，如0.4.2，而如果出现了0.5.0这样的版本，是不会更新的。

	"engines" : {
		"node": ">= 0.10.0"
	}
指定node的版本必须大于0.10.0：

	"scripts" : {
		"test" : "grunt test"
	}
这里指定的是在npm命令行中输入的命令与实际命令的对应关系。例如，这里是说当我们在控制台输入npm test的时候，实际执行npm grunt test。

##### 三、bower实践

mkdir bower-in-action
cd bower-in-action
mkdir jquery-bootstrap-in-action
cd jquery-bootstrap-in-action

bower install jquery
把jquery装上其最新稳定版本
bower install bootstrap

http://bower.io/search 这个地址支持对所有的官网可获得的bower包的搜索。在其中输入jquery owner:jquery，可以搜索出所有jquery团队开发的包含jquery关键字的包。如果只输入jquery，则所有包含jquery关键字的包都会出现，不管它是不是jquery团队开发的。
如果你需要安装的是比较小众的包，而这个包在bower的库中没有怎么办呢？bower提供了其它的几种方式可供使用。
（1）通过github的短写安装，如
	bower install jquery/jquery
前面一个jquery是jquery在github上注册账号的名字，后一个jquery在github上项目的名字
（2）通过github完整的项目地址，如
	bower install https://github.com/jquery/jquery.git
（3）通过URL进行安装，例如
	npm install http://lib.sinaapp.com/js/jquery/1.7.2/jquery.min.js

在项目中设置一个bower.json文件之后，执行
	bower install
就会把其中定义的所有以来都安装好。要生成bower.json文件，只需要输入
	bower init
命令即可。
生成一个.bowerrc文件：
输入一个
	vim .bowerrc
命令
然后编辑其内容为：
	{
	"directory":"bower_coponents",                    //设置安装bower包的目录
	"proxy":”http://proxy.tencent.com:8080",         //用于配置代理
	"https-proxy":”https://proxy.tencent.com:8080",  //如果代理用的是https，则用这种方式配置代理
	"timeout":60000                                   //如果你的网络环境非常的差，可以设置一下timeout，其默认值是60000，单位时ms，你可以将其改为更长的时间，以便于安装或更新其中的依赖包的时候可以顺利安装。
	}


四、grunt实践

	npm install -g generator-webapp

	mkdir grunt-in-action
	cd grunt-in-action
	mkdir grunt-by-yo
	cd grunt-by-yo
	yo webapp grunt-by-yo

提示是否使用node-sass时选择no，因为这个工具目前还存在一些莫名其妙的问题，不是很好用。

在编辑器中打开当前项目。然后打开Gruntfile.js：

	'use strict';

	module.exports = function(grunt){
		require('time-grunt')(grunt);//这个模块用于记录任务花了多长时间运行，在我们优化项目build的时间时有用
		require('load-grunt-tasks')(grunt);//自动加载tasks

		//可配置的路径
		var config = {
			app:’app’,
			dist:’dist'
		};


		grunt.initConfig({
			config : config,  //像config这样的项，由于没有同名插件，对于这种没有通明插件的项，会被作为常量存储起来，在配置文件中以<%= %>这样的方式调用，如下文的<%= config.app %>
				   watch: {	  //而像watch这样的项，由于存在同名插件grunt-contrib-watch，这个插件在运行的时候，会直接读取Gruntfile.js中的同名项，然后根据其中的配置来运行。当然，要让grunt-contrib-watch插件运行，必须加载它，即grunt.loadNpmTask(‘grunt-npm-watch’)；但是，如果有很多任务需要加载的时候，一个个去加载他们显然有些费劲，因此就有人开发了一个工具，自动将package.json中所定义的依赖作为任务全部加载进来。即上文的require('load-grunt-tasks')(grunt);这一句。load-grunt-tasks就是这个工具的模块名字。

				bower: {
					files: ['bower.json'],
					tasks: ['wiredep']
				},
				js: {
					files:['<%= config.app %>/scripts/{,*/}*.js'],
					tasks: ['jshint'],
					options:{
						livereload:true
					}
				},
				jstest: {
					files: ['test/spec/{,*/}*.js'],
					tasks: ['test:watch']
				}
			}
		})
	}


其中的config : config, 除了这种方式，还有一种常用的方式如下 ：
	pkg : grunt.file.readJSON('package.json'),
就是把package.json中的所有配置读取进来，供后面以<%= pkg.***** %>的方式使用。

每一个task中又可以包含自己的options和target

比如，执行sass这一task下的dis这个target，则可以用命令行：
	grunt sass:dist
一个个的task可以组合在一起，组合在一起的组合任务还可以和其它的组合任务组合成更大的组合目录。

两种注册任务的方式：

	grunt.registerTask(‘某组合task的名字’，function(target){
		grunt.task.run([’任务名’，’任务名’,’任务名’]);
	})

或者

	grunt.registerTask(‘某组合task的名字’,[
		'任务名',
		'任务名',
		'任务名'
	])



grunt 命令后面不跟任何参数的时候，会默认执行default这一组合task

常见的开源协议的宽松度比较：

MIT的宽松度>BSD> ISC> Apache> GPL

	npm init
	npm install grunt --save-dev    #在安装安装包的时候，加入--save-dev参数的话，意味着同时将其加入package.json的devDependencies项中；而如果只加 --save参数的话，意味着加入dependencies项中。

	npm install load-grunt-tasks --save-dev
	npm install time-grunt --save-dev
	touch Gruntfile.js

grunt 的文件拷贝依赖于官方的插件 grunt-contrib-copy，用如下命令行安装：
	grunt install grunt-contrib-copy —save-dev
grunt 中文件的删除则依赖于官方的插件 grunt-contrib-clean，用如下命令安装：
	grunt install grunt-contrib-clean —save-dev


下面一步步创建项目：

Gruntfile.js：

	'use strict';

	module.exports = function(grunt){
		require('time-grunt')(grunt);//这个模块用于记录任务花了多长时间运行，在我们优化项目build的时间时有用
		require('load-grunt-tasks')(grunt);//自动加载tasks

		//可配置的路径
		var config = {
			app:'app',
			dist:'dist'
		};


		grunt.initConfig({
			config : config,  //像config这样的项，由于没有同名插件，对于这种没有通明插件的项，会被作为常量存储起来，在配置文件中以<%= %>这样的方式调用，如下文的<%= config.app %>

			copy:{
				dist: {
					files:{
						'<%= config.dist %>/index.html' : '<%= config.dist %>/index.html',   //这里键值对的键是目标文件，值是源文件，值既可以是单个值，也可以是一个数组
						'<%= config.dist %>/js/index.js' : ［'<%= config.dist %>/js/index.js'］
					}
				},
				dist_js: {
					files:[
						{
							expand:true,
							cwd:'<%= config.app %>/', //注意：初学者经常忘记这里的/
							src:'*.html',
							dest:'<%= config.dist %>/',
							ext:'.min.js',
							extDot:'last', //表示从源文件命中的第一个点处开始修改文件的后缀，比如，源文件是index.max.js的话，目标文件会变成index.max.min.js。这个值还可以设置成first
							flatten: true, //flatten为true的话会直接把中间各层目录去掉，导致的结果是生成的文件在dist目录下，而且dist目录下的js目录被删除掉了。
							rename: function(dest,src){
								return dest + 'js/' + src;   //这样又可以将生成的文件放回dist的js文件夹下。它是在ext,extDoc,flatten等参数执行完之后才执行的。
							}
						}
					]
				}
			｝

			clean:{
				dist:{
					src:['<%= config.dist %>/**/*'],    //注意，一个＊表示匹配任意一个字符，但不包括反斜杠；两个＊表示匹配任意个数的任意字符，包括反斜杠。｛a,b}的形式则表示匹配a或者b。如果是！，则表示匹配取反。
					filter:'isFile'，  //filter的取值既可以是node.js的
					//fs.Status这个类下的函数名，包括isFile\isDrectory\isBlockDevice\isCharacterDevice\isSumbolicLink\isFIFO\isSocket，也可以是function(filepath){ return (!grunt.file.isDir(filepath)); } 这样的自定义处理函数。这里的设置是指删除文件，不删除文件夹的意思。
					dot: true, // dot为真的话，会命中以.开头的通明文件。比如，我们如果我们前面有设置匹配的是index.html文件话，那么如果设置了dot:true则会把.index.html也同时匹配上。
					matchBase:true, // 如果我们要匹配的是a?b，那么这里指的是可以匹配到／xyz/123/acb，但不会匹配到/xyz／acb/123
					expand:true, //意味着我们要处理动态的src到dest文件的映射。
				}
			}


			watch: {	  //而像watch这样的项，由于存在同名插件grunt-contrib-watch，这个插件在运行的时候，会直接读取Gruntfile.js中的同名项，然后根据其中的配置来运行。当然，要让grunt-contrib-watch插件运行，必须加载它，即grunt.loadNpmTask(‘grunt-npm-watch’)；但是，如果有很多任务需要加载的时候，一个个去加载他们显然有些费劲，因此就有人开发了一个工具，自动将package.json中所定义的依赖作为任务全部加载进来。即上文的require(‘load-grunt-tasks’)(grunt);这一句。load-grunt-tasks就是这个工具的模块名字。

				bower: {
					files: ['bower.json'],
					tasks: ['wiredep']
				},
				js: {
					files:['<%= config.app %>/scripts/{,*/}*.js'],
					tasks: ['jshint'],
					options:{
						livereload:true
					}
				},
				jstest: {
					files: ['test/spec/{,*/}*.js'],
					tasks: ['test:watch']
				}
			}
		})
	}

剖析grunt tasks —— grunt serve

	mkdir grunt-in-action
	cd grunt-in-action
	mkdir grunt-yo-webapp
	cd grunt-yo-webapp
	yo webapp grunt-yo-webapp

完成之后，查看Gruntfile.js可以看到关于serve这个task组合的配置。

下面开始对这个项目自动生成的Gruntfile.js进行解析：

我们在命令行中输入
	grunt serve
即可看到项目的浏览效果。而且如果我们在编辑器中修改页面的代码，动态地就可以展示到浏览器上，不用我们刷新浏览器。这是serve这个组合task帮我们自动完成的。如果在运行grunt serve命令的时候加上--allow-remote，则可以在局域网的其它机器上通过运行这个任务的机器的ip地址:9000/页面地址的方式访问到项目中的页面。

connect:dist:keepalive这个语句是什么意思呢？
对于task名:abc:def:ghi这样的语句，grunt会解析成
this.flags  { abc:true, def:true, ghi:true}
然后在执行任务的时候会去读取this.flags中的这些值。

wiredep这个task是用来根据bower.json的依赖文件来自动引入这些依赖的js和css文件到页面代码中。避免一个个手动去引入。

concurrent:server用来通过concurrent这个任务来指定server这一target并行执行。因为grunt中的任务默认是串行执行的。concurrent这个任务是用来让任务并行执行的。其中的server这一target从其源代码查看可知它是用来将sass编译成css，并拷贝到对应的输出目录。

因为webapp-generator生成的项目中使用了 sass，而sass依赖于ruby，所以用
	brew install ruby
命令先把ruby 安装上。然后用
	sudo npm install -g sass
把sass安装上。


<a name='js-angular'></a>
#### JavaScript之AngularJS

<a name='js-jade'></a>
#### JavaScript之Jade模版

<a name='js-node'></a>
#### JavaScript之node.js

##### 开启新纪元——进击node.js学习笔记（一）

node.js 的版本常识：
偶数版为稳定版本，基数版为非稳定版本。开发的话一定要使用稳定版本，即使用像0.6.x,0.8.x,0.10.x,0.12.x这样的版本。

mac系统下的node.js安装：
<pre>
xcode-select -p
xcode-select --install
python -V   #注意这里是大写的V
ruby -v
</pre>
打开brew.sh网站，把homebrew的安装语句
<pre>
ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
</pre>
拷贝到终端上执行它。
<pre>
brew install node
</pre>
当然，也可以用homebrew来安装mogodb、git等等。语句为brew install mogodb git
<pre>
node -v
</pre>

使用npm install -g n安装n模块，可以用n模块来安装指定的node版本和切换不同的node版本。比如，如果想安装0.10.33版本的node.js，就可以在终端中输入：
<pre>
n 0.10.33
</pre>
安装完后，可以在终端中输入n，然后按向上或向下方向键来切换至你所需的node.js版本。

在终端中输入node所进入的执行环境与浏览器的控制台中所进入的环境是不一样的，一些顶层的对象会有区别。比如，在前者中输入process会打印出来该对象，在后者中输入window会打印出来该对象。但是，如果在前者中输入window或者在后者中输入process都会报错。

##### 如何用node.js建立一个服务器，提供调试AJAX请求的测试环境

首先来看怎样用node.js启动一个服务器。代码比较简单，如下所示：
<pre>
var http = require('http'); //  依赖一个用js写好了的http模块
http.createServer(function(req,res){
	res.writeHead( 200, { 'content-type' : 'plain/text' } );
	res.end('Hello, node.js!\n');
}).listen(1337,'127.0.0.1');
</pre>

其中的
<pre>
function(req,res){
	res.writeHead( 200, { 'content-type' : 'plain/text' } );
	res.end('Hello, node.js!\n');
}
</pre>
是一个匿名的回调函数。指的是当监听到127.0.0.1的1337端口的访问后，用该匿名回调函数进行回调处理。

上面是用node.js启动一个服务器的基本操作。如果更进一步的话，我们可以修改它成一个突出jsonp数据的后台服务，用以提供前端开发时AJAX请求的测试环境。

<pre>
var http = require('http'),
	util = require('util'),
	url = require('url');
http.createServer(function (req, res) {
	var myJsonpCallback = url.parse(req.url,true).query.callbackParam,//从访问地址中解析出来callbackParam的值
		responseData = {
			github:'paiangit',
			name:'paian'
		} ;//responseData是要发回客户端的json数据
	console.log('Request received: \n');
	console.log('从url中取得的参数值为' + myJsonpCallback +'\n');//打印出callbackParam这一URL参数的值
	util.log('Request recieved: \nmethod: ' + req.method + '\nurl: ' + req.url);
	res.writeHead(200, { 'Content-Type': 'text/plain' });
	req.on('data', function () {
		console.log('Data received!');
	});
	res.end(myJsonpCallback + '(' + JSON.stringify(responseData) + ')');
}).listen(1337,'127.0.0.1');
console.log('Server running on port http://127.0.0.1:1337/');
</pre>

相应地，前台的AJAX请求可以这么写：
<pre>
$.ajax({
	url:"http://127.0.0.1:1337/",
	dataType:'jsonp',
	data:{
		'adata':adata   //这是随异步请求发送给服务端的某条数据，当然也可以不发送
	},
	jsonp:'callbackParam',
	jsonpCallback:"myJsonpCallback",
	/*这里的jsonp和jsonpCallback两个参数会组合成callbackParam=myJsonpCallback的形式附加在请求的URL后面。
	*上文中node.js代码的var myJsonpCallback = url.parse(req.url,true).query.callbackParam这一语句就是用来
	*获取所发来的请求的URL中的URL中callbackParam=myJsonpCallback的callbackParam参数的值的。
	*获得这个值之后会套在返回的json串外面，构成jsonp,实现跨域。服务端返回的数据格式是这样的:
	* myJsonpCallback({
	*	 github:'paiangit',
    *    name:'paian'
	* })
	*/
	success:function(result){
		console.log('My github is' + result.github);
		console.log('And my name is' + result.name);
	},
	error:function(){
		console.log('Sorry, the request is playing a joke!')
	}
	timeout:3000
});
</pre>

<a name='optimization'></a>
#### 前端性能优化技巧总结

<a name='tool'></a>
#### 前端工具的使用

##### 调试神器之Charles抓包工具的使用：

在你进行调试的时候，可能需要把本地的某个javascript或css文件替换掉线上的某个页面中对应的javascript或css文件，进行在线调试。这时你就需要一个抓包替换工具。比如Windows系统下的fiddler。这里我讲一下Mac系统下的一个与fiddler类似的工具——Charles。

首先打开Charles工具，切换到sequence，刷新你要抓包的页面，可以抓到所有的请求。然后你找到你需要的替换的某个javascript或css文件，选中它右键单击，选择map url，然后选择本地的文件。然后点Charles中的刷新按钮，即可把该请求指向本地的资源。这样可以方便地进行调试。

<a name='component'></a>
#### 前端插件或组件的开发

##### 非插件或组件化的javascript文件写法——;(function(window,undefined){})(window)的理解

对于一个非插件或组件化的javascript文件，其常见写法为：
<pre>
;(function(window,undefined){
	// do something here
})(window)
</pre>
为什么要写得这么绕呢？这是很多新入行的同学所困惑的问题。

首先，为什么要把window对象作为参数传入进去呢？
主要原因如下：
window是DOM对象模型的最顶层对象。ECMA Script在执行function(){}内部的语句时，每次执行一句跟window对象相关的语句都要去外层找一遍window对象，而如果把window对象作为变量传入进去，那么就可以直接访问到。这种速度要比去外层找window对象要快。有人写了如下这两段代码来检测传入window对象与不传入该对象在执行效率上的不同：
<pre>
var num = 10000;
// 代码1
(function(window, undefined){
    var a1 = new Date();
    for (var i = 0; i < num; i++) {
        document.write(window["pp" + i]);
    }
    var a2 = new Date();
    alert(a2.getTime() - a1.getTime());
})(window);
// 代码2
(function(undefined){
    var a1 = new Date();
    for (var i = 0; i < num; i++) {
        document.write(window["pp" + i]);
    }
    var a2 = new Date();
    alert(a2.getTime() - a1.getTime());
})();
</pre>
通过在浏览器的控制台中执行它们，可以清晰地看出执行这两段代码的效率上的区别：前者明显比前者执行的时间更短。

其次，为什么外面传入的只有window这一个参数，而里面却有两参数呢（多了个undefined）？
 一方面，undefined在JavaScript中并不属于保留字/关键字，因此在ie5.5-ie8中我们可以将其当作变量那样对其赋值（IE9+及其他现代浏览器中赋值给undefined将无效），也就是说undefined 在ie5.5-ie8等浏览器中是可以作为变量名而赋予其它值的。这样，它就有可能被人修改成其它的值。所以需要将undefined的值在我们的程序范围内重置回undefined，以保证不受到外界的影响。如何重置呢？实参不传入内容，而形式参数是undefined的情况下，因为实参未定义，所以形式参数undefined获得的值就是undefined。
另一方面是因为在一些老浏览器中直接使用undefined会报错，考虑到兼容性，因此使用未定义实参的方式来生成一个undefined值传给内部的形式参数undefined。这样，在其内部再使用undefined的时候，就不会报错了。此外要注意，不要把window.undefined作为实参传递给形参，因为window.undefined可能被其他人修改了。所以最好的方式就是什么都不传，那样形参的undefined就会因实参未定义而成为真正的undefined了。


###第二篇 体悟篇
（待续）